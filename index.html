
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>dmonster&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="none">
<meta property="og:type" content="website">
<meta property="og:title" content="dmonster&#39;s blog">
<meta property="og:url" content="http://dmonster.top/index.html">
<meta property="og:site_name" content="dmonster&#39;s blog">
<meta property="og:description" content="none">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dmonster&#39;s blog">
<meta name="twitter:description" content="none">
  
    <link rel="alternative" href="/atom.xml" title="dmonster&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">dmonster&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello my world!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/sitemap.xml">sitemap</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="dmonster.top">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-ping-traceroute-mtr" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/12/ping-traceroute-mtr/" class="article-date">
  <time datetime="2018-07-12T08:59:03.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/12/ping-traceroute-mtr/">ping,traceroute,mtr</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <p>这是在实习中遇到的一个小问题，说实话，还是能学到很多东西的</p>
<p>背景是这样的：一个客户反应他们的主机网络有问题，丢包，然后，我先往主机上ping，通的，想看一下路由哪丢包，于是就mtr，结果发现最后一跳不可达，于是traceroute试一下，也不可达。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>贴：当发送一个ECHO_REQUEST时，将发送时间记录在报文里，并复制到远端主机相应的ECHO_REPLY报文中。当接收到ECHO_REPLY时，通过比较当前时间与报文时间计算出耗费时间。如果没有收到符合icmp_seq的报文，则认为该报文丢失</p>
<p>ps：好吧，我也弄不懂这是啥玩意，总之就是发送一个icmp包，通过返回信息看他是通还是不通</p>
<h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><p>再贴：traceroute会在IP头里设置TTL，先发1，然后第一跳路由器收到后TTL-1，变0，路由器判断丢弃反馈一个ICMP time exceeded<br>traceroute收到后，知道这个路径后继续发一个TTL为2的，然后就会发现第二个路由器，<br>最终达到目的IP的路由后会选择送到一个udp高端口（30000以上，即没有这种端口号，真变态）,获取一个ICMP port unreachable的消息，来验证确认可达</p>
<p>traceroute有一个固定的时间等待响应(ICMP TTL到期消息)。如果这个时间过了，它将打印出一系列的*号表明：在这个路径上，这个设备不能在给定的时间内发出ICMP TTL到期消息的响应。然后，Traceroute给TTL记数器加1，继续进行。</p>
<h2 id="mtr"><a href="#mtr" class="headerlink" title="mtr"></a>mtr</h2><p>跟traceroute类似，只是是用icmp协议</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>比如一个IP117.50.43.183，我ping，他是通的，</p>
<p>然后traceroute：</p>
<pre><code>traceroute to 117.50.43.183 (117.50.43.183), 30 hops max, 60 byte packets
1 10.11.200.45 (10.11.200.45) 0.448 ms 0.406 ms 0.439 ms
2 107.150.96.1 (107.150.96.1) 14.262 ms 17.157 ms 17.143 ms
3 172.25.17.1 (172.25.17.1) 7.117 ms 7.419 ms 7.509 ms
4 128.14.158.37 (128.14.158.37) 7.630 ms 128.14.158.33 (128.14.158.33) 6.825 ms 6.944 ms
5 192.254.84.16 (192.254.84.16) 1.035 ms 2.046 ms 2.074 ms
6 218.30.48.241 (218.30.48.241) 1.401 ms 192.254.81.48 (192.254.81.48) 1.404 ms 0.848 ms
7 218.30.48.241 (218.30.48.241) 1.004 ms 59.43.186.217 (59.43.186.217) 8.917 ms 218.30.48.241 (218.30.48.241) 0.981 ms
8 59.43.186.213 (59.43.186.213) 8.953 ms 59.43.248.130 (59.43.248.130) 9.278 ms 59.43.248.106 (59.43.248.106) 8.482 ms
9 59.43.182.142 (59.43.182.142) 129.264 ms 128.608 ms 59.43.182.138 (59.43.182.138) 137.349 ms
10 59.43.182.138 (59.43.182.138) 137.380 ms 59.43.247.101 (59.43.247.101) 190.740 ms 59.43.246.162 (59.43.246.162) 154.466 ms
11 59.43.247.101 (59.43.247.101) 190.368 ms 59.43.246.162 (59.43.246.162) 154.076 ms 153.944 ms
12 202.97.14.213 (202.97.14.213) 189.197 ms 59.43.246.162 (59.43.246.162) 161.843 ms 153.470 ms
13 202.97.34.77 (202.97.34.77) 182.545 ms 202.97.34.73 (202.97.34.73) 163.622 ms *
14 220.181.0.30 (220.181.0.30) 160.095 ms 220.181.177.222 (220.181.177.222) 194.610 ms *
15 220.181.177.222 (220.181.177.222) 189.952 ms 220.181.0.30 (220.181.0.30) 171.656 ms 171.188 ms
16 36.110.169.194 (36.110.169.194) 165.222 ms 218.30.28.14 (218.30.28.14) 166.458 ms 36.110.169.194 (36.110.169.194) 165.041 ms
17 36.110.169.194 (36.110.169.194) 160.074 ms * 164.930 ms
18 * * *
19 * * *
20 * * *
21 * * *
22 * * *
23 * * *
24 * * *
25 * * *
26 * * *
27 * * *
28 * * *
29 * * *
30 * * *
</code></pre><p>可以看到30跳之后就不通了，抓包可知traceroute默认是使用udp协议，而默写骨干路由节点/防火墙对一些udp包的访控限制或者过滤，然后换成icmp模式(或者用tcp模式 -T)：</p>
<pre><code>traceroute -I 117.50.43.183
traceroute to 117.50.43.183 (117.50.43.183), 30 hops max, 60 byte packets
1 10.11.200.45 (10.11.200.45) 0.673 ms 0.657 ms 0.654 ms
2 107.150.96.1 (107.150.96.1) 17.214 ms 17.306 ms 17.459 ms
3 172.25.17.1 (172.25.17.1) 921.836 ms 926.200 ms 926.464 ms
4 128.14.158.37 (128.14.158.37) 10.069 ms 10.083 ms 10.083 ms
5 192.254.81.58 (192.254.81.58) 1.506 ms 1.655 ms 1.792 ms
6 192.254.81.48 (192.254.81.48) 1.292 ms 0.905 ms 1.097 ms
7 218.30.48.241 (218.30.48.241) 1.134 ms 1.296 ms 1.293 ms
8 59.43.248.130 (59.43.248.130) 9.160 ms 9.173 ms 8.984 ms
9 59.43.189.17 (59.43.189.17) 8.747 ms 8.735 ms 8.656 ms
10 59.43.182.142 (59.43.182.142) 129.364 ms 129.340 ms 129.329 ms
11 59.43.247.101 (59.43.247.101) 179.181 ms 179.138 ms 179.172 ms
12 59.43.246.158 (59.43.246.158) 181.041 ms 181.076 ms 181.067 ms
13 * * *
14 202.97.34.73 (202.97.34.73) 154.926 ms 155.297 ms 155.444 ms
15 * * *
16 220.181.0.30 (220.181.0.30) 161.878 ms 162.084 ms 179.252 ms
17 36.110.169.194 (36.110.169.194) 165.605 ms 157.566 ms 157.244 ms
18 * * *
19 * * *
20 * * *
21 * * *
22 * * *
23 * * *
24 * * *
25 * * *
26 * * *
27 117.50.43.183 (117.50.43.183) 156.832 ms 156.803 ms 156.823 ms
28 117.50.43.183 (117.50.43.183) 158.333 ms * *
29 117.50.43.183 (117.50.43.183) 164.555 ms * *
30 117.50.43.183 (117.50.43.183) 156.988 ms 157.116 ms 157.118 ms
</code></pre><p>可以看到虽然中间大量不可达，但是通过抓包得知，他的ttl还是再不断增加，所以最后还是可以通的</p>
<p>mtr<br><img src="https://i.imgur.com/B1KYpyp.png" alt=""></p>
<p>可见最后一跳迷失了，为什么呢？继续抓包，发现ttl从17跳以后就重置变回1了，所以其实mtr也是可以在不可达的情况下增加ttl但是一般只能增加5，而这个案例之间跨的运营商服务器就非常多，最终导致看起来不可达</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后真相大白，真的要感谢我同事大佬，太流弊了，还有就是一定要花时间研究一下抓包技术了。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2018/07/12/ping-traceroute-mtr/" data-id="cjjicwa1h001ccsug13j8pmmi" class="article-share-link" data-share="baidu" data-title="ping,traceroute,mtr">分享到</a>
      

      
        <a href="http://dmonster.top/2018/07/12/ping-traceroute-mtr/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx负载均衡" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/05/nginx负载均衡/" class="article-date">
  <time datetime="2018-07-05T08:02:10.000Z" itemprop="datePublished">2018-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nginx/">nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/05/nginx负载均衡/">nginx负载均衡</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <p>nginx配置不再多说</p>
<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>直接贴配置：</p>
<pre><code>server {
    listen 80;
    server_name a.a.a.a;    //当前vhost地址
    ssl off;
    root html;
    index index.html index.htm;
    location /proxy/ {
        proxy_pass http://x.x.x.x:port/;        //server地址,注意最后加上端口和“/”
    }
}
</code></pre><p>如访问a.a.a.a/proxy/index.html，实际上访问的是x.x.x.x/index.html</p>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>即在http{}加入：</p>
<pre><code>upstream name {
    server x.x.x.x:port weight=1;
    server x.x.x.x:port weight=1;
    。。。
}
</code></pre><p>weight为权重值，越大所有到的负载越高</p>
<p>然后将location{}中的的proxy_pass改成</p>
<pre><code>proxy_pass http://name/;
</code></pre><h1 id="获取客户端真实ip"><a href="#获取客户端真实ip" class="headerlink" title="获取客户端真实ip"></a>获取客户端真实ip</h1><h2 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h2><p>我的理解： X-Forwarded-For为请求header中需要手动添加的东西，它会按顺序记录所有配置并经过的ip</p>
<ul>
<li><p>参数设置</p>
<pre><code>proxy_set_header X-Forwarded-For *；
</code></pre><p>  其中</p>
<ul>
<li>*为 $remote_addr ：获取并添加最近的ip，</li>
<li>*为 $proxy_add_x_forwarded_for ：添加获得的请求头中所有的ip</li>
</ul>
</li>
</ul>
<p>我的理解是，如果客户端出口配置了代理（包括nginx，cdn等），并且没有设置X-Forwarded-For，那么之后的header中就不会写入客户端的地址，server就无法获取到真实地址了。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2018/07/05/nginx负载均衡/" data-id="cjjicwa1k001ecsugbdigjfsg" class="article-share-link" data-share="baidu" data-title="nginx负载均衡">分享到</a>
      

      
        <a href="http://dmonster.top/2018/07/05/nginx负载均衡/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx搭建web服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/04/nginx搭建web服务器/" class="article-date">
  <time datetime="2018-07-04T02:40:21.000Z" itemprop="datePublished">2018-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nginx/">nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/04/nginx搭建web服务器/">nginx搭建web服务器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><ol>
<li>openssl</li>
<li>nginx</li>
<li>gcc</li>
</ol>
<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>yum然后就ok了，需要说的是yum安装的nginx默认主目录是 /usr/share/nginx，然后配置文件在 /etc/nginx/nginx.conf</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>vi /etc/nginx/nginx.conf</p>
<h2 id="server配置"><a href="#server配置" class="headerlink" title="server配置"></a>server配置</h2><p>不知道是我的原因还是我主机的原因，我的配置文件以开始就没有server{}参数，google了一下有人说本来就是这样，但是网上的教程都说以开始就有。。。</p>
<h3 id="http配置"><a href="#http配置" class="headerlink" title="http配置"></a>http配置</h3><pre><code># For more information on configuration, see:
#   * Official English Documentation: http://nginx.org/en/docs/
#   * Official Russian Documentation: http://nginx.org/ru/docs/

#运行用户
user nginx;

#启动进程,通常设置成和cpu的数量相等
worker_processes auto;

#全局错误日志及PID文件
error_log /var/log/nginx/error.log;

pid /var/run/nginx.pid;

# Load dynamic modules. See /usr/share/nginx/README.dynamic.
include /usr/share/nginx/modules/*.conf;

#工作模式及连接数上限
events {
#单个后台worker process进程的最大并发链接数   
worker_connections  1024;
}

http {
#设定日志格式
log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;
                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;
                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;

access_log  /var/log/nginx/access.log  main;

#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.
sendfile            on;
tcp_nopush          on;
tcp_nodelay         on;
#连接超时时间
keepalive_timeout   65;
types_hash_max_size 2048;

#设定mime类型,类型由mime.type文件定义
include             /etc/nginx/mime.types;
default_type        application/octet-stream;

#设定虚拟主机配置
server {
    #监听端口，http默认为80
    listen 80;
    #即访问方式，可填域名/ip/localhost等
    server_name www.abc.com;
    #是否开启ssl
    ssl off;
    #定义服务器默认网站根目录位置
    root html;
    #定义索引文件
    index index.html index.htm;
    #默认请求
    location / {
        root /etc/nginx/html/;
    }
}
# Load modular configuration files from the /etc/nginx/conf.d directory.
# See http://nginx.org/en/docs/ngx_core_module.html#include
# for more information.
include /etc/nginx/conf.d/*.conf;
}
</code></pre><h3 id="https配置"><a href="#https配置" class="headerlink" title="https配置"></a>https配置</h3><p>其他一样，server{}部分：</p>
<pre><code>server {
    #https侦听端口默认为443
    listen 443;
    server_name localhost;
    #打开ssl
    ssl on;
    root html;
    index index.html index.htm;

    #这两个为从域名申请的证书，放在etc/nginx下
    ssl_certificate   cert/1531309350240.pem;
    ssl_certificate_key  cert/1531309350240.key;

    ssl_session_timeout 5m;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;
    location / {
        root html;
        index index.html index.htm;
    }
}
</code></pre><h3 id="location详解"><a href="#location详解" class="headerlink" title="location详解"></a>location详解</h3><ul>
<li><p>匹配规则</p>
<ul>
<li>/        ：全匹配</li>
<li>~     ：波浪线表示执行一个正则匹配，区分大小写</li>
<li>~*    :表示执行一个正则匹配，不区分大小写</li>
<li>^~    :^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</li>
<li>=     :进行普通字符精确匹配</li>
<li>@     :”@” 定义一个命名的 location，使用在内部定向时，例如：error_page, try_files</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>index ：定义索引页</li>
<li><p>root ：指定虚拟根目录</p>
<p>  配置段：http、server、location、if</p>
<pre><code>#在地址栏输入xxx.com/hello.html时，服务器到/var/html目录下找hello.html文件
location / {
    root /var/html/；
}

#在地址栏输入xxx.com/html/hello.html时，服务器到/var/html目录下找hello.html文件
location /html/ {
    root /var/；
}
</code></pre></li>
<li><p>alias ：定义一个目录别名</p>
<p>  配置段：location</p>
<pre><code>#在地址栏输入xxx.com/var/hello.html时，服务器到/var目录下找hello.html文件
location /html/ {
    alias /var/；
}
</code></pre><p>  注意这里不会再/html/下找文件，因为alias会把location后的目录丢掉，alias值定义一个目录的别名</p>
</li>
</ul>
</li>
</ul>
<h1 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h1><ul>
<li>找不到目录<ol>
<li>首先检查配置文件中的root，location确定配置目录无误</li>
<li>找到需要访问的文件，确认文件名和后缀无误</li>
<li>查看配置文件中server_name参数，如果实在地址栏中访问ip或域名，则把localhost改成相应的ip或域名</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2018/07/04/nginx搭建web服务器/" data-id="cjjicwa1q001kcsugejku1vdg" class="article-share-link" data-share="baidu" data-title="nginx搭建web服务器">分享到</a>
      

      
        <a href="http://dmonster.top/2018/07/04/nginx搭建web服务器/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql主从复制及读写分离" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/03/mysql主从复制及读写分离/" class="article-date">
  <time datetime="2018-07-03T08:36:53.000Z" itemprop="datePublished">2018-07-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/03/mysql主从复制及读写分离/">mysql主从复制及读写分离</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p><img src="https://images2015.cnblogs.com/blog/1043616/201612/1043616-20161213151808011-1732852037.jpg" alt=""></p>
<h2 id="主"><a href="#主" class="headerlink" title="主"></a>主</h2><ol>
<li><p>修改mysql配置文件</p>
<pre><code>[mysqld]
log-bin=mysql-bin        //开启binlog日志
server-id=1            //设置唯一id
</code></pre></li>
<li><p>重启mysql</p>
<pre><code>service mysqld restart
</code></pre></li>
<li><p>创建用于同步的用户账号</p>
<p> 登陆mysql</p>
<pre><code>CREATE USER &apos;repl&apos;@&apos;123.456.7.89&apos; IDENTIFIED BY &apos;slavepass&apos;;        //创建用户，其中repl为用户名，123.456.7.89为该用户名所在从库的ip，若有多个可用正则表达式匹配
GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;123.456.7.89&apos;;        //分配权限
flush privileges;        //刷新权限
</code></pre></li>
<li><p>查看master状态，记录binlog文件名和position位置</p>
<pre><code>mysql&gt; show master status;
+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000001 |      154 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
</code></pre></li>
</ol>
<h2 id="从"><a href="#从" class="headerlink" title="从"></a>从</h2><ol>
<li><p>修改mysql配置文件</p>
<pre><code>[mysqld]
server-id=2     //设置server-id
</code></pre></li>
<li><p>重启mysql</p>
</li>
<li><p>登陆mysql执行同步sql语句</p>
<pre><code>mysql&gt; CHANGE MASTER TO
    -&gt;     MASTER_HOST=&apos;a.b.c.d&apos;,     //主库ip地址
    -&gt;     MASTER_USER=&apos;repl&apos;,
    -&gt;     MASTER_PASSWORD=&apos;slavepass&apos;,
    -&gt;     MASTER_LOG_FILE=&apos;mysql-bin.000001&apos;,
    -&gt;     MASTER_LOG_POS=154;
</code></pre></li>
<li><p>启动slave同步</p>
<pre><code>mysql&gt;start slave;
</code></pre></li>
<li><p>查看slave状态</p>
<pre><code>mysql&gt; show slave status\G;
*************************** 1. row ***************************
       Slave_IO_State: Waiting for master to send event
          Master_Host: a.b.c.d
          Master_User: repl
          Master_Port: 3306
        Connect_Retry: 60
      Master_Log_File: mysql-bin.00001
  Read_Master_Log_Pos: 11662
       Relay_Log_File: mysqld-relay-bin.000022
        Relay_Log_Pos: 11765
Relay_Master_Log_File: mysql-bin.00001
     Slave_IO_Running: Yes
    Slave_SQL_Running: Yes
      Replicate_Do_DB: 
  Replicate_Ignore_DB: 
...
</code></pre><p> 当Slave_IO_Running    和    Slave_SQL_Running都为yes时主从同步设置就成功了</p>
</li>
</ol>
<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><ul>
<li><p>在my.cnf中</p>
<pre><code>binlog-ignore-db = db_name  //设置不同步库
binlog-do-db = db_name    //只同步哪些库，其他不同步
</code></pre><p>  在查看master状态时，可以看见以上配置的结果</p>
</li>
</ul>
<h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p><img src="http://heylinux.com/wp-content/uploads/2011/06/mysql-master-salve-proxy.jpg" alt=""></p>
<h2 id="关于读写分离中slave的选择"><a href="#关于读写分离中slave的选择" class="headerlink" title="关于读写分离中slave的选择"></a>关于读写分离中slave的选择</h2><p>应用层中不可能因为底层架构的问题而修改源码，所以万一选择的一台slave挂了就没办法了，所以：<br><img src="http://s3.51cto.com/wyfs02/M02/4C/46/wKioL1Q6Z3aj0qD3AAFTRVV5DP0026.jpg" alt=""><br>其中对proxy来说，slave的选择可以交给另外一个组件，比如haproxy来完成</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2018/07/03/mysql主从复制及读写分离/" data-id="cjjicwa1e0018csugyeomg2ol" class="article-share-link" data-share="baidu" data-title="mysql主从复制及读写分离">分享到</a>
      

      
        <a href="http://dmonster.top/2018/07/03/mysql主从复制及读写分离/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql误删恢复（更新）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/03/mysql误删恢复（更新）/" class="article-date">
  <time datetime="2018-07-03T05:05:03.000Z" itemprop="datePublished">2018-07-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/03/mysql误删恢复（更新）/">mysql误删恢复（更新）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <p>觉得这个还挺重要的，就看了一下，还有很多情况和相应的操作，以后遇到了再更新</p>
<h1 id="mysqlbinlog恢复"><a href="#mysqlbinlog恢复" class="headerlink" title="mysqlbinlog恢复"></a>mysqlbinlog恢复</h1><p>因为mysqlbinlog在mysql中是默认不开启的，所以需要先开启mysqlbinlog，不再多说。</p>
<ol>
<li><p>首先找到mysqlbinlog目录，默认是在/var/lib/mysql下的，可用ll查找binlog文件的创建日期来判断使用哪个binlog文件</p>
</li>
<li><p>查看binlog文件（binlog文件中有很多二进制数），用–start-date 或者 –start-position指定需要恢复的段，将误操作/误删除的sql语句剔除或者导出后手工剔除，然后导出为textlog.sql文件</p>
</li>
<li><p>导入恢复表</p>
<pre><code>mysql -uroot -p &lt; textlog.sql
</code></pre></li>
</ol>
<h1 id="使用最近一次的备份文件恢复"><a href="#使用最近一次的备份文件恢复" class="headerlink" title="使用最近一次的备份文件恢复"></a>使用最近一次的备份文件恢复</h1><ol>
<li><p>完整备份</p>
<pre><code>mysqldump -uroot -p Test_DB &gt; /data/mysqlbackup/Test_DB_bk.sql  //将Test——BD完整备份为Test_DB_bk.sql
</code></pre></li>
<li><p>剔除误操作/误删除语句</p>
</li>
<li><p>恢复</p>
<pre><code>mysqldump -uroot -p Test_DB &lt; /data/mysqlbackup/Test_DB_bk.sql    //将Test_DB_bk.sql备份文件导入Test_DB
</code></pre></li>
<li><p>注意：如果真的使用最近的一次备份文件去做的话，一定是在万不得已的情况（比如binlog 被删除，整个硬盘挂掉、、、 想想都可怕。。。）</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2018/07/03/mysql误删恢复（更新）/" data-id="cjjicwa21001vcsugahvt3vq7" class="article-share-link" data-share="baidu" data-title="mysql误删恢复（更新）">分享到</a>
      

      
        <a href="http://dmonster.top/2018/07/03/mysql误删恢复（更新）/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql登陆问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/03/mysql登陆问题/" class="article-date">
  <time datetime="2018-07-03T04:05:47.000Z" itemprop="datePublished">2018-07-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/03/mysql登陆问题/">mysql登陆问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <p>今天本来是想做点小实验的，结果被mysql登陆的问题折磨了半天，后悔上课没认真听啊!</p>
<h1 id="登陆失败"><a href="#登陆失败" class="headerlink" title="登陆失败"></a>登陆失败</h1><p>如果是报密码错误，不管怎么样，先破解，登陆进去再说。</p>
<ol>
<li><p>停掉mysqld服务</p>
<pre><code>service mysqld stop
</code></pre></li>
<li><p>破解</p>
<pre><code>mysqld_safe --skip-grant-tables &amp;    //进入交互模式
mysql -uroot -p            //直接回车进入
update user set password=PASSWORD(&quot;newpassword&quot;)where user=&quot;root&quot;;         //设置新密码
flush privileges;         //更新权限
quit
</code></pre><h2 id="再次登陆还是报错"><a href="#再次登陆还是报错" class="headerlink" title="再次登陆还是报错"></a>再次登陆还是报错</h2><p>分析mysql登陆模式，mysql分sock登陆和tcp登陆</p>
</li>
</ol>
<ul>
<li><p>如果是报sock错误，找到mysql.sock文件，查看它和/etc/my.cnf中的sock的路径是否一样</p>
</li>
<li><p>如果报登陆或者密码错误，试着输入</p>
<pre><code>mysql -uroot -p -h127.0.0.1
mysql -uroot 
</code></pre><p>试试能否登陆进去，登陆进去之后查看user的配置</p>
<pre><code>use mysql;
select * from user 
</code></pre><p>  <img src="https://i.imgur.com/Dt36iXX.png" alt=""><br>可以看到因为不写 -h 参数是默认的地址是localhost 但是localhost的用户和密码都是空，所以写入密码时用户认证失败</p>
<ul>
<li>ps：影响不大，如果非要改的话，注意密码为md5加密的</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2018/07/03/mysql登陆问题/" data-id="cjjicwa160012csugdgjtn52f" class="article-share-link" data-share="baidu" data-title="mysql登陆问题">分享到</a>
      

      
        <a href="http://dmonster.top/2018/07/03/mysql登陆问题/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-prox搭建以及遇到的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/28/mysql-prox搭建以及遇到的问题/" class="article-date">
  <time datetime="2018-06-28T06:03:19.000Z" itemprop="datePublished">2018-06-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/28/mysql-prox搭建以及遇到的问题/">mysql-prox搭建以及遇到的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <ul>
<li>proxy：uhost-ubuntu</li>
<li>mysql：udb</li>
</ul>
<p>描述：因为udb在内网，不能通过外网直接访问，所以需要一个连接eip的uhost来做proxy，且uhost和MySQL须在同一内网中互相能ping通</p>
<h1 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h1><ul>
<li><p>下载安装</p>
<pre><code>apt-get install mysql-proxy
</code></pre></li>
<li><p>获取版本信息</p>
<pre><code>mysql-proxy -V
</code></pre><p>  <img src="https://i.imgur.com/3vf31oT.png" alt=""><br>  ps：注意.lua文件    </p>
</li>
<li><p>配置</p>
<pre><code>vi /etc/mysql-proxy.cnf

输入：
    [mysql-proxy]            #标志
    admin-username=root     #admin用户名
    admin-password=123fsck    #admin密码
    admin-lua-script=/usr/lib64/mysql-proxy/lua/admin.lua    #lua位置，参见上面的版本信息
    daemon=true        # mysql-proxy以守护进程方式运行
    keepalive=true        #保持连接启动进程会有2个， 一号进程用来监视二号进程
    proxy-backend-addresses=10.6.X.XX  #目标地址，udb内网地址，默认端口3306
    log-file=/var/log/mysql-proxy.log
    log-level=debug

chmod 0660 /etc/mysql-proxy.cnf   //更改权限
</code></pre></li>
<li><p>开启服务</p>
<pre><code>mysql-proxy --defaults-file=/etc/mysql-proxy.cnf
</code></pre></li>
</ul>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ol>
<li><p>uhost的ubuntu的apt源过旧，无法安装mysql-proxy </p>
<ol>
<li><p>添加apt-get源： </p>
<pre><code>vi /etc/apt/sources.list
</code></pre><p> 源可参考：<a href="https://blog.csdn.net/chentengkui/article/details/72633988" title="国内外apt源" target="_blank" rel="noopener">国内外apt源</a></p>
</li>
<li><p>添加完之后: </p>
<pre><code>apt-get update  //更新软件源
</code></pre></li>
</ol>
</li>
<li><p>配置完成后依旧无法添加</p>
<ol>
<li><p>在控制台登陆mysql，检查用户名，密码是否正确</p>
</li>
<li><p>在uhost上远程登陆mysql，检查udb的mysql当前用户是否允许远程登陆</p>
</li>
<li><p>检查当前主机网络是否连通uhost   </p>
</li>
<li><p>检查uhost外网防火墙是否打开proxy配置的端口</p>
</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2018/06/28/mysql-prox搭建以及遇到的问题/" data-id="cjjicwa1b0016csugrhs6u892" class="article-share-link" data-share="baidu" data-title="mysql-prox搭建以及遇到的问题">分享到</a>
      

      
        <a href="http://dmonster.top/2018/06/28/mysql-prox搭建以及遇到的问题/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小玩意/">小玩意</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-centos上搭建shadowsocks的两种方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/26/centos上搭建shadowsocks的两种方法/" class="article-date">
  <time datetime="2018-06-26T09:24:59.000Z" itemprop="datePublished">2018-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/26/centos上搭建shadowsocks的两种方法/">centos上搭建shadowsocks的两种方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <p>这两个月刚好在XXX公司实习，给了我一个账号买主机实验用，于是利用工作之便搭建了一个shadowsocks的服务器。github上找了一下，大概发现两个可用的。</p>
<ul>
<li>ps：主机为centosos6.5 </li>
</ul>
<h2 id="方法一-python"><a href="#方法一-python" class="headerlink" title="方法一 python"></a>方法一 python</h2><p>这个方法搭建的服务器只能以进程运行，不能搭建服务。</p>
<ol>
<li><p>安装pip</p>
<pre><code>yum install python-pip
</code></pre></li>
<li><p>使用pip安装shadowsocks</p>
<pre><code>pip install shadowsocks
</code></pre></li>
<li><p>配置Shdowsocks服务,并启动</p>
<p> 用vim新建 /etc/shadowsocks.json 文件, 并写入以下内容</p>
<pre><code>{
&quot;server&quot;:&quot;0.0.0.0&quot;,  //指定连接的ip（所有人都可连接就为0.0.0.0）
&quot;server_port&quot;:443,    //指定服务端口
&quot;local_address&quot;:&quot;127.0.0.1&quot;,
&quot;local_port&quot;:1080,
&quot;password&quot;:&quot;your-passwd&quot;,    //设置密码
&quot;timeout&quot;:300,
&quot;method&quot;:&quot;aes-256-cfb&quot;,    //设置加密方式
&quot;fast_open&quot;:false,
&quot;workers&quot;:5        //启动的进程数
}
</code></pre><p> 还有多用户模式的配置我就不弄了，可自行百度，因为就我自己用，而且单用户也可以多方连接。</p>
<pre><code>启动:ssserver -c /etc/shadowsocks.json -d start 
关闭:ssserver -c /etc/shadowsocks.json -d stop
</code></pre></li>
</ol>
<h2 id="方法二-脚本搭建"><a href="#方法二-脚本搭建" class="headerlink" title="方法二 脚本搭建"></a>方法二 脚本搭建</h2><p>这个方法可以启服务</p>
<ol>
<li><p>下载安装</p>
<pre><code>cd /tmp
wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh
chmod +x shadowsocks-libev.sh
./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log
</code></pre></li>
<li><p>按照提示步骤安装即可</p>
<p> 看到enjoy it！就说明完成了</p>
</li>
<li><p>查看是否安装完成</p>
<pre><code>ps -ef | grep ss-server | grep -v ps | grep -v grep
</code></pre></li>
<li><p>配置<br>配置文件在 /etc/shadowsocks-libev/config.json</p>
<pre><code>{
   &quot;server&quot;:[&quot;[::0]&quot;,&quot;0.0.0.0&quot;], //ipv4/ipv6
&quot;server_port&quot;:your_server_port,
&quot;local_address&quot;:&quot;127.0.0.1&quot;,
&quot;local_port&quot;:1080,
&quot;password&quot;:&quot;your_password&quot;,
&quot;timeout&quot;:600,
&quot;method&quot;:&quot;aes-256-cfb&quot;
}
</code></pre><p> 基本相同，只不过支持ipv6</p>
</li>
<li><p>卸载</p>
<pre><code>cd /tmp  # 进入 shadowsocks-libev.sh 所在目录
./shadowsocks-libev.sh uninstall
</code></pre></li>
<li><p>启动</p>
<pre><code>service shadowsocks start   # 启动
service shadowsocks stop    # 停止
service shadowsocks restart # 重启
</code></pre></li>
</ol>
<h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><ul>
<li><p>问题：访问谷歌出现505/500报错，不能翻</p>
<p>  因为我是在云主机上搭建的，云主机外网ip在pnat设备上，不再本机，有外设防火墙，所以要到控制台上设置一下规则，允许设置的端口走tcp流量</p>
</li>
<li><p>指定端口时不建议用常用端口，容易被墙</p>
</li>
<li><p>如果要在云主机上搭建，主机配置最低就行，但是eip最好带宽大一点，不然速度慢</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2018/06/26/centos上搭建shadowsocks的两种方法/" data-id="cjjicwa2e0028csug5okhtoo4" class="article-share-link" data-share="baidu" data-title="centos上搭建shadowsocks的两种方法">分享到</a>
      

      
        <a href="http://dmonster.top/2018/06/26/centos上搭建shadowsocks的两种方法/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小玩意/">小玩意</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CDN内容分发网络" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/26/CDN内容分发网络/" class="article-date">
  <time datetime="2018-06-26T07:49:39.000Z" itemprop="datePublished">2018-06-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/26/CDN内容分发网络/">CDN内容分发网络</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <h1 id="CDN架构"><a href="#CDN架构" class="headerlink" title="CDN架构"></a>CDN架构</h1><p>最简单的CDN网络只需一台负责全局负载均衡的DNS和中心节点，边缘节点各节点一台Cache，即可运行。DNS支持根据用户源IP地址解析不同的IP，实现就近访问。为了保证高可用性等，CDN网管中心需要监控各节点的流量、健康状况等。一个节点的单台Cache承载数量不够时，才需要多台Cache，多台Cache同时工作时，才需要负载均衡器，使Cache群协同工作。</p>
<h1 id="中心节点"><a href="#中心节点" class="headerlink" title="中心节点"></a>中心节点</h1><p>中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责整个CDN网络的分发及管理。</p>
<h2 id="CDN网管中心"><a href="#CDN网管中心" class="headerlink" title="CDN网管中心"></a>CDN网管中心</h2><p>CDN网管中心是整个CDN能够正常运转的基础保证，它不仅能对整个CDN网络中的各个子系统和设备进行实时监控，对各种故障产生相应的告警，还可以实时监测到系统中总的流量和各节点的流量，并保存在系统数据库中，使网管人员能够方便地进行进一步分析。一套完善的网管系统，允许用户按需对系统配置进行修改。</p>
<h2 id="全局负载均衡DNS"><a href="#全局负载均衡DNS" class="headerlink" title="全局负载均衡DNS"></a>全局负载均衡DNS</h2><p>全局负载均衡DNS通过一组预先定义好的策略，将当时最接近用户的Cache节点地址提供给用户，使用户能够得到快速的服务。同时，它还与分布在各地的所有CDN节点保持持续通信，搜集各节点的通信状态，确保不会将用户的请求分发到不可用、或不健康的Cache节点上。</p>
<h1 id="边缘节点"><a href="#边缘节点" class="headerlink" title="边缘节点"></a>边缘节点</h1><p>CDN边缘节点主要指异地分发节点，由负载均衡设备、高速缓存服务器两部分组成。</p>
<h2 id="负载均衡设备"><a href="#负载均衡设备" class="headerlink" title="负载均衡设备"></a>负载均衡设备</h2><p>负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点的工作效率；同时还负责收集节点与周围环境的信息，保持与全局负载均衡DNS的通信，实现整个系统的负载均衡。</p>
<p>##高速缓存服务器<br>高速缓存服务器（Cache）负责存储客户网站的大量信息，就像一个靠近用户的网站服务器一样响应本地用户的访问请求。通过全局负载均衡DNS的控制，用户的请求被透明地指向离他最近的节点，节点中Cache服务器就像网站的原始服务器一样，响应终端用户的请求。因其距离用户更近，故其响应时间才更快。</p>
<h1 id="CDN四大关键技术"><a href="#CDN四大关键技术" class="headerlink" title="CDN四大关键技术"></a>CDN四大关键技术</h1><h2 id="内容路由技术"><a href="#内容路由技术" class="headerlink" title="内容路由技术"></a>内容路由技术</h2><p>CDN负载均衡系统实现CDN的内容路由功能。它的作用是将用户的请求导向整个CDN网络中的最佳节点。最佳节点的选定可以根据多种策略，例如距离最近、节点负载最轻等。负载均衡系统是整个CDN的核心。</p>
<ul>
<li><p>通常负载均衡可以分为两个层次:全局负载均衡(GSLB)和本地负载均衡(SLB)。</p>
<ul>
<li><p>全局负载均衡(GSLB)主要的目的是在整个网络范围内将用户的请求定向到最近的节点(或者区域)。</p>
<p>  对于全局负载均衡而言，为了执行就近性判断，通常可以采用两种方式，一种是静态的配置，例如根据静态的IP地址配置表进行IP地址到CDN节点的映射。另一种方式是动态的检测，例如实时地让CDN节点探测到目标IP的距离(可以采用RRT，Hops作为度量单位)，然后比较探测结果进行负载均衡。当然，静态和动态的方式也可以综合起来使用。</p>
</li>
<li><p>本地负载均衡一般局限于一定的区域范围内，其目标是在特定的区域范围内寻找一台最适合的节点提供服务，因此，CDN节点的健康性、负载情况、支持的媒体格式等运行状态是本地负载均衡进行决策的主要依据。</p>
<p>  对于本地负载均衡而言，为了执行有效的决策，需要实时地获取Cache设备的运行状态。获取的方法一般有两种，一种是主动探测，一种是协议交互。主动探测针对SLB设备和Cache设备没有协议交互接口的情况，通过ping等命令主动发起探测，根据返回结果分析状态。另一种是协议交互，即SLB和Cache根据事先定义好的协议实时交换运行状态信息，以便进行负载均衡。比较而言，协议交互比探测方式要准确可靠，但是目前尚没有标准的协议，各厂家的实现一般仅是私有协议，互通比较困难。</p>
</li>
</ul>
</li>
<li>负载均衡可以通过多种方法实现，主要的方法包括DNS、应用层重定向、传输层重定向等等。</li>
</ul>
<h2 id="内容分发技术"><a href="#内容分发技术" class="headerlink" title="内容分发技术"></a>内容分发技术</h2><p>内容分发包含从源到CDN边缘的Cache的过程。从实现上看，有两种主流的内容分发技术:PUSH和PULL.</p>
<ul>
<li><p>push是一种主动分发技术</p>
<p>  通常，push有内容管理系统发起，将内容从内容源芬达到边缘cache节点。分发协议可采用http/ftp等</p>
</li>
<li><p>pull是一种被动分发技术</p>
<p>  PULL分发通常由用户请求驱动。当用户请求的内容在本地的边缘Cache上不存在(未命中)时，Cache启动PULL方法从内容源或者其他CDN节点实时获取内容。</p>
</li>
</ul>
<h2 id="内容存储技术"><a href="#内容存储技术" class="headerlink" title="内容存储技术"></a>内容存储技术</h2><p>对于CDN系统而言，需要考虑两个方面的内容存储问题。一个是内容源的存储，一个是内容在Cache节点中的存储</p>
<ul>
<li>对于内容源的存储，由于内容的规模比较大(通常可以达到几个甚至几十个TB)，而且内容的吞吐量较大，因此，通常采用海量存储架构。如NAS和SON.</li>
<li>对于在Cache节点中的存储，是Cache设计的一个关键问题。需要考虑的因素包括功能和性能两个方面:在功能上包括对各种内容格式的支持、对部分缓存的支持，在性能上包括支持的容量、多文件吞吐率、可靠性、稳定性。</li>
</ul>
<h2 id="内容管理技术"><a href="#内容管理技术" class="headerlink" title="内容管理技术"></a>内容管理技术</h2><ul>
<li><p>本地内容索引。 本地内容管理首先依赖于对本地内容的了解。包括每个Cache设备上内容的名称、URL、更新时间、内容信息等。本地内容索引是实现基于内容感知的调度的关键。</p>
</li>
<li><p>本地内容拷贝。通常，为了提高存储效率，同一个内容在一个CDN节点中仅存储一份，即仅存储在某个特定的Cache上。但是一旦对该内容的访问超过该Cache的服务提供能力，就需要在本地(而不是通过PUSL的方式)实现内容的分发。这样可以大大提高效率。</p>
</li>
<li><p>本地内容访问状态信息收集。搜集各个Cache设备上各个内容访问的统计信息，Cache设备的可用服务提供能力及内容变化的情况。</p>
</li>
</ul>
<p>可以看出，通过本地内容管理，可以将内容的管理从原来的Cache设备一级，提高到CDN节点一级，从而大大增加了CDN的可扩展性和综合能力。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2018/06/26/CDN内容分发网络/" data-id="cjjicwa0e000icsugu2nfserw" class="article-share-link" data-share="baidu" data-title="CDN内容分发网络">分享到</a>
      

      
        <a href="http://dmonster.top/2018/06/26/CDN内容分发网络/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python爬虫之验证码识别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/26/python爬虫之验证码识别/" class="article-date">
  <time datetime="2018-03-26T09:07:44.000Z" itemprop="datePublished">2018-03-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python3/">python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/26/python爬虫之验证码识别/">python爬虫之验证码识别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做django的小项目，在提交表单登陆的问题上由于有验证码这个东西，产生了一个逻辑问题，就是怎么先获取验证码，返回到页面给用户，再提交，以开始是想用celery，但是好像不怎么好用celery本来是做异步提高效率的，于是索性直接在post请求的同时识别出验证码。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2018/03/26/python爬虫之验证码识别/" data-id="cjjicwa1o001icsugnsjcnu1g" class="article-share-link" data-share="baidu" data-title="python爬虫之验证码识别">分享到</a>
      

      
        <a href="http://dmonster.top/2018/03/26/python爬虫之验证码识别/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小玩意/">小玩意</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python3/">python3</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCNA/">CCNA</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCNP/">CCNP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小玩意/">小玩意</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a><span class="tag-list-count">15</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">6</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/12/ping-traceroute-mtr/">ping,traceroute,mtr</a>
          </li>
        
          <li>
            <a href="/2018/07/05/nginx负载均衡/">nginx负载均衡</a>
          </li>
        
          <li>
            <a href="/2018/07/04/nginx搭建web服务器/">nginx搭建web服务器</a>
          </li>
        
          <li>
            <a href="/2018/07/03/mysql主从复制及读写分离/">mysql主从复制及读写分离</a>
          </li>
        
          <li>
            <a href="/2018/07/03/mysql误删恢复（更新）/">mysql误删恢复（更新）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
     
	<div class="widget-wrap"> 
		<h3 class="widget-title">Weibo show</h3> 
		<div class="widget-weibo"> 
			<iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=5&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=5753916666&verifier=c645597d&dpc=1"></iframe>
		</div> 
	</div> 

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 dmonster<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/sitemap.xml" class="mobile-nav-link">sitemap</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>


<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>dmonster&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="none">
<meta property="og:type" content="website">
<meta property="og:title" content="dmonster&#39;s blog">
<meta property="og:url" content="http://dmonster.top/page/2/index.html">
<meta property="og:site_name" content="dmonster&#39;s blog">
<meta property="og:description" content="none">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dmonster&#39;s blog">
<meta name="twitter:description" content="none">
  
    <link rel="alternative" href="/atom.xml" title="dmonster&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">dmonster&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello my world!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/sitemap.xml">sitemap</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="dmonster.top">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-MPLS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/24/MPLS/" class="article-date">
  <time datetime="2017-11-23T16:19:25.000Z" itemprop="datePublished">2017-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/24/MPLS/">MPLS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <h1 id="MPLS"><a href="#MPLS" class="headerlink" title="MPLS"></a>MPLS</h1><ol>
<li><p>ARP</p>
<p> 地址解析协议：用已知6的ip地址来求未知目的mac地址</p>
<p> arp隶属于icmp协议，icmp：互联消息控制管理协议</p>
<p> icmp通过一系列消息实现各种工具功能，如ping和arp</p>
<p> arp包含两个消息 一个叫广播请求，一个叫单播回应</p>
</li>
<li><p>proxy arp ：代理arp</p>
<p> 路由器接口默认启用代理arp，代理arp替代目标给请求者回应，同时代理arp帮助路由器请求目标mac   实际上是将数据包引向下一跳</p>
</li>
<li><p>路由器数据转发时的帧头重写</p>
<p> pc0 -》pc1</p>
<p> D-mac s-mac<br> 12-1  12-a<br> d-ip  s-ip<br> 1.2   2.2</p>
<p> 路由器在数据转发过程中先路由，路由完毕后必须对帧头重写，重写的目的是</p>
<p> 将目标mac换成路径沿途下一跳设备的mac地址，帮助数据往前走一步    </p>
<p> 将源mac替换为路由器出口的mac地址，为了数据返回的时候可以靠近目的地</p>
</li>
<li><p>路由器数据转发机制</p>
<ol>
<li><p>进程转发 process forword ： 淘汰了，过老的技术</p>
<p> 路由器的每一次arp请求都是通过源于终端的流量触发的，并且请求结果不会缓存下来，相同设备通讯，需要反复的重复请求</p>
</li>
<li><p>缓存转发 cache forword 一次路由多次交换 ： 淘汰</p>
<p> rewrite switch 路由器创建arp缓存表，缓存被请求得到的目标主机mac地址，相同设备通讯，就不需要额外的重复请求</p>
<p> 无论进程转发还是缓存转发，第一次arp请请求都是通过终端流量触发</p>
</li>
<li><p>快速转发 cef 思科快速转发 </p>
<ol>
<li><p>cef详解</p>
<ol>
<li><p>cef两张表</p>
<p> cef默认开启，如果希望关闭cef : no ip cef</p>
<p> FIB :forwardin information base :转发信息库</p>
<p> FIB 会周期性检查RIB（路由表），并且渎职下载RIB内容</p>
<p> FIB假设所有目标网络都是要被访问的，FIB主动对目标网络下一跳做arp探查（请求）</p>
<p> CEF假设RIB中目标网络所包含的主机都会被访问，所以CEF就提前对目标网络的下一跳做ARP请求，并将结果缓存，这样就不需要流量出发ARP请求</p>
<p> ADJ-table : 邻接表</p>
<p> 该表中存放这目标网络，下一跳，以及出口和需要替换的帧头信息</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>4. 路由器上RIB、FIB、ADJ-table关系

    RIB时FIB素材的提供者，ADJ-table的内容来自于FIB的请求结果，数据抵达后先看FIB 利用FIB和ADJ-table 完成数据转发

- cef缺陷

    cef本身的匹配查找还是逐条最长匹配，所以效率特别低
</code></pre><ol>
<li><p>mpls</p>
<ol>
<li><p>mpls概述</p>
<p> 多协议标签交换 ，是一种数据转发机制，是为了取代ip转发</p>
<p> 现在mpls已经和iP完满融合</p>
<p> mpls是基于CEF的</p>
<p> OSI 7层模型上看，mpls是2.5层技术      帧头/包头/断头/负载/帧尾</p>
<p> mpls在枕头的后面，包头的前面插入了一个新的头部信息     帧头/标签/包头/断头/负载/帧尾</p>
<p> ！！补充</p>
<ol>
<li><p>路由器收到数据后如何判断使用路由转发还是用mpls转发</p>
<p> 帧头里包含了一个以太网帧类型字段，不同数值的意义不一样</p>
</li>
</ol>
</li>
<li><p>mpls标签内容</p>
<p> mpls标签其实就是数据转发的依据，类似mac地址和ip地址概念</p>
<p> mpls标签长度32bit，4字节。</p>
<p> 前20bit 标签取值范围   约等于与100w个标签<br> 紧接着1bit为栈底位，最早被压入数据头部的标签，栈底位为1，含义是告诉路由器，读完该标签没必要在往后读了，因为后面是包头了</p>
<p> 再接着3bit为EXP（体验位）：3bit 0-7 8个数值，代表了不同的转发优先级别</p>
<p> 最后8bit为ttl（time to live 生存周期） </p>
</li>
<li><p>mpls的模式</p>
<ol>
<li>帧模式 ：frame mode 以太网里启用mpls，label插在帧头后面</li>
<li>信元模式： cell mode ：同步传输网络中（atm）启用mpls，label插在信元头后面</li>
</ol>
</li>
<li><p>mpls术语</p>
<ol>
<li>LABEL：标签</li>
<li><p>LSR：标签交换路由器   启用mpls的路由器</p>
<ol>
<li>入栈LSR：启用了mpls，接收了ip数据，压入标签，转发出去</li>
<li>连路中LSR：接收了带有标签的数据，完全依赖标签转发数据</li>
<li><p>出栈LSR：需要将标签移除，将数据还原传递给ip网络</p>
<p>入栈LSR和出栈LSR是相对的</p>
</li>
</ol>
</li>
<li><p>LSP label switch path：标签交换路径</p>
<p> lsp就是标签关联后形成的源到目的的逻辑通路，类似路由路径</p>
</li>
<li><p>TDP、LDP</p>
<ol>
<li>TDP：标记分发协议</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>    2. LDP：标签分发协议

    TDP和LDP实际上就是负责标签分配，分发，关联，维护的技术

5. 标签的操作

    压入，交换，移出，弹出
</code></pre><ol>
<li><p>作用</p>
<ol>
<li>是一个更快速的数据转发技术</li>
<li>能减少核心网洛内参与bgp的设备数量和减少bgp peer关系</li>
</ol>
</li>
<li><p>LDP</p>
<ol>
<li><p>LDP的作用</p>
<ol>
<li><p>LDP帮助直连设备形成LDP邻居关系</p>
<p> LDP的邻居是通过HELLO消息的发送发现的</p>
<p> LDP HELLO消息是基于UDP，目标端口646</p>
<p> LDP的邻居关系是通过HEOOL消息建立的</p>
<p> LDP邻居关系的建立基于TCP，目标端口646</p>
<p> LDP RID概念：启用LDP设备的route-id，RID是LDP邻居关系建立时所用的的，所以必须可达</p>
</li>
<li><p>LDP负责给FIB表中目标网络分配标签</p>
<p> 0~15是保留的，FIB表中的路由条目对应的目标网络LDP是无法进行标签分配的</p>
<p> 本地标签 ： LL</p>
</li>
<li><p>LDP需要负责将本地网络对应的本地标签分发给其他LDP邻居</p>
<p> LDP在分发标签信息的时候，两个方式：</p>
<ol>
<li>上游主动：ATM沿用</li>
<li><p>下游主动：以太网络沿用</p>
<p>上下游按照数据流方向做判断</p>
<p>LDP标签分发的实际机制：本地网络对应本地标签给所有邻居。</p>
</li>
</ol>
</li>
<li><p>标签的关联</p>
<p> 标签关联是目标网路、本地标签及对应的远程标签、下一跳、出口、二层重写信息关联而来</p>
</li>
</ol>
<ul>
<li><p>注意</p>
<p>  bound address : 被绑定地址</p>
<p>  参与MPLS设备的RID和启用MPLS的接口IP都是绑定地址</p>
<p>  绑定地址会随着本地标签共享出去</p>
<p>  设备提供的绑定地址与路由表中的下一跳匹配了，那么设备提供的远程标签就可以关联</p>
</li>
</ul>
<ol>
<li><p>标签路径的维护</p>
<p> LSP其实和路由路径是重叠的</p>
<p> 路由路径如果发生变化，RIB一定变化，FIB表随之变化，LDP本身又基于FIB表，所以一切跟着变</p>
</li>
</ol>
</li>
<li><p>特殊的标签概念</p>
<ol>
<li><p>到数第二跳 POP label </p>
<p> POP LABEL 是当前路由器分配给本地直连网络的标签</p>
<p> POP LABEL 最终会成为倒数第二跳的远程标签，而这个POP LABEL概念是弹掉标签，数据回复成ip包，提高转发效率（实际上就是恢复成ip数据包丢给倒数第一条设备，帮助倒数第一跳设备少查一次标签转发信息库，提高数据转发效率）</p>
</li>
<li><p>UNTAG 标签  未标记标签</p>
<p> 一半MPLS核心网底层协议是ospf的时候出现</p>
<p> 当前设备找不到对应的目标网络远程标签，就会分配untag</p>
<p> 远程标签如果是untag，所有标签被移除，在传递给下一跳</p>
</li>
<li><p>路由器标签操作动作</p>
<ol>
<li>压入</li>
<li>交换</li>
<li>弹出</li>
<li>移除</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>4. MPLS的表项

    1. LIB：标签信息库

        所有目标网络的本地标签信息，和邻居分享过来的远程标签都存储在这

    2. 标签转发信息库

        目标网络本地标签、本地标签、关联结果、出口、下一跳 存放于这里

5. MPLS表项与RIB、FIB的关系


6. 补充知识

    MPLS的控制平台与数据传输平台

    MPLS的控制平台负责完成所有数据传输所需的表项

    MPLS的传输平台

7. MPLS的配置流程

    1. 确保CEF开启

            router（config）# ip cef

    2. 设定MPLS的相关参数

            mpls label protocol &lt;ldp/tdp&gt;   //选择MPLS的标签分配分发协议

            mpls ldp router-id &lt;looback x&gt;    //手动设定MPLS的LDP RID

            mpls label range &lt;xx yy&gt;           //设定MLS的标签取值范围

        这些命令都是可选配置，不是一定要配置

    3. 接口下启用MPLS

            interface x
            ip mpls


8. MPLS校验流程

        show mpls ldp discovery detail  //确认MPLS LDP是否发现邻居

        show mpls ldp neighbor            //确认MPLS LDP 邻居表是否建立

        show mpls ldp binding              // 查看MPLS LIB表

        show mpls forwarding-table      //查看MPLS LFIB表

        show adj detail

9. 网络中哪些接口和设备需要参与和启用MPLS

    需要形成LDP邻居关系的，需要分发标签的，才启用MPLS


10. 补充知识

    MPLS transport address ： MPLS传输地址

    MPLS邻接关系，实际上是利用传输地址完成的，LDP RID 默认就是传输地址

    no host router to transport address ：这个提示不是报错，而是说没有主机路由抵达

    no route to transport addr:这个提示%100报错



11. 补充知识

    1. 偏移列表

        偏移列表是rip和eigrp用的，用于将路由封信的开销进行累加

        先编写acl，再在rigrp下offset

            acc 2 per 2.2.2.0 0.0.0.255
            router eigrp 1
            offset 1 in 100000 fa 0/0
            net 12.12.12.0 0.0.0.255
</code></pre><h1 id="MPLS-VPN"><a href="#MPLS-VPN" class="headerlink" title="MPLS VPN"></a>MPLS VPN</h1><ol>
<li><p>什么是vpn </p>
<p> 虚拟的专用网络，VPN可以分成两种： 数据加密、对等体认证</p>
<pre><code>不加密数据，也不做认证，只组建专有网络
</code></pre></li>
<li><p>MPLS VPN的作用</p>
<p> 运营商网络是MPLS VPN的核心，通过共享客户网络的路由信息，实现专用通信访问</p>
</li>
<li><p>MPLS VPN中的术语</p>
<ol>
<li>p-network   网络服务提供商<ol>
<li>p 设备  服务提供商核心网络核心设备</li>
<li>pe设备  服务提供商边界设备</li>
</ol>
</li>
<li>c-network  客户网络<ol>
<li>ce设备   客户边界设备</li>
</ol>
</li>
<li><p>vrf 虚拟路由转发表    </p>
<p> vrf是位于pe设备上的，由pe设备针对不同的c-network创建</p>
<p> vrf用来隔离和区分、存储不同c-network的路由信息        </p>
</li>
<li><p>MP-bgp 多协议的bgp</p>
<p> mp-bgp就是为了mpls-vpn出现的，mp-bgp实际上是在传统的bgpv4基础上激活的。</p>
<p> mp-bgp出现就是为了帮助pe设备共享vrf的路由信息</p>
</li>
<li><p>vrf中的rd与rt</p>
<ol>
<li><p>RD：路由区分值</p>
<p> 格式是xx：xx ，不同vrf的相同路由进入mp-bgp转发表后会利用rd来区分</p>
</li>
<li><p>RT：路由目标值</p>
<p> RT值是两个：导出RT值、导入RT值，格式也是x:x</p>
<p> vrf路由进入mp-bgp，编程mp-bgp更新是，携带导出RT值，对端接收到mp-bgp更新后，利用导出rt值和导入rt值进行匹配比较，确认路由进入哪个vrf</p>
</li>
</ol>
<ul>
<li><p>vrf rd rt的关系</p>
<p>  mp-bgp允许rd和rt成为路由更新属性的一部分，传统bgp做不到</p>
<p>  mp-bgp共享的路由更新叫vpnv4更新</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>MPLS VPN中双标签的作用</p>
<ol>
<li><p>MPLS VPN中的栈顶标签 是帮助数据流穿越p-net抵达配pe设备</p>
<p> 栈顶标签是p-net中ldp负责分配，分发，关联的</p>
</li>
<li><p>MPLS VPN中的栈底标签</p>
<p> vrf的路由条目信息进入mp-bgp转发表，变成bgp路由更新时，由bgp分配标签，该标签记录了目标网络与vrf的关联关系，并且在最终数据的传递是帮助数据抵达正确vrf</p>
</li>
</ol>
</li>
<li><p>ce设备如何和pe设备交换路由信息</p>
<ol>
<li><p>静态路由</p>
<p> ce设备上静态路由的设置只需要将下一跳指向pe即可</p>
<p> pe设备上静态路由的设置</p>
<pre><code>ip route vrf &lt;name&gt; &lt;目标网络&gt; &lt;下一跳&gt;
</code></pre><p> pe设备查看vrf表</p>
<pre><code>show ip vrf &lt;name&gt;
</code></pre><p> pe设备需要ping c-network</p>
<pre><code>ping vrf &lt;name&gt; &lt;目标网络&gt;
</code></pre></li>
<li><p>利用动态路由协议</p>
<ol>
<li><p>rip</p>
<p> ce上rip的配置是常规的</p>
<p> pe上的rip配置</p>
<pre><code>router rip
address-family ipv4 vrf &lt;name&gt;
no auto-summary
version 2
network &lt;主网信息&gt;
</code></pre></li>
<li><p>eigrp</p>
<p> ce上eigrp的配置常规</p>
<p> pe设备上</p>
<pre><code>router eigrp&lt;as-id&gt;
address-family ipv4 vrf &lt;name&gt;
no auto-summary
autonomous-system &lt;as-id&gt;  //重申as号
network &lt;xxxxxx&gt;
</code></pre></li>
<li><p>ospf</p>
<p> ce设备上配置常规</p>
<p> pe设备上</p>
<pre><code>router ospf &lt;p-id&gt; vrf &lt;name&gt;
router-id &lt;xxx&gt;
network &lt;xxxx&gt; &lt;xxxx&gt; area &lt;id&gt;
</code></pre></li>
<li><p>bgp</p>
<p> ce设备上bgp配置常规</p>
<p> pe设备上bgp的配置</p>
<pre><code>router bgp &lt;as-id&gt;
address-family ipv4 vrf &lt;name&gt;
neighbor &lt;xxx&gt; remote-as &lt;as-id&gt;
</code></pre></li>
</ol>
</li>
</ol>
</li>
</ol>
<ol>
<li>将pe设备上vrf路由带入mp-bgp同时将mp-bgp路由带入vrf（类似双向重分发）</li>
</ol>
<h2 id="mpls-vpn的配置流程"><a href="#mpls-vpn的配置流程" class="headerlink" title="mpls vpn的配置流程"></a>mpls vpn的配置流程</h2><ol>
<li><p>从p-net开始配置</p>
<ol>
<li><p>完成igps的配置</p>
<p> 是为了bgp和ldp的rid 或 对等体地址可达</p>
</li>
<li><p>开启cef完成mpls的配置</p>
</li>
<li><p>完成pe设备上bgp的配置及mp-bgp的激活</p>
<pre><code>router bgp &lt;as-id&gt;
bgp router-id &lt;xxx&gt;
neighbor &lt;peer-address&gt; remote-as &lt;as-id&gt;
neighbor &lt;peer-address&gt; update-source loopback 0
address-family vpnv4 unicast //进入bgp配置模式
neighbor &lt;peer-address&gt; actively    //在原本的对等体基础上激活mp-bp关系
show ip bgp vpnv4 all summary  //查看mp-bgp对等体关系

clear ip bgp vpnv4 unicast 1 soft out   //mpbgp软清除
</code></pre><p> 2和3一定不能配反，否则mpls-vpn无法正常工作</p>
</li>
</ol>
</li>
</ol>
<pre><code>        router bgp &lt;as-id&gt;
        neighbor &lt;peer-address&gt; default-information //向对等体发送一条缺省路由

4. 完成pe设备上vrf的创建，并且将接口划入vrf

        ip vrf &lt;name&gt;     //创建指定名称的vrf表
        rd &lt;x:x&gt;
        route-target &lt;both/import/outport&gt;    //定义了rt的导入导出值
        interface &lt;intf-id&gt;
        ip vrf forwarding &lt;vrfname&gt;  //接口划入vrf（接口划入vrf中，会将ip抹除一次）
        ip address &lt;xxxxx&gt; &lt;xxxxx&gt; 

        show ip vrf   //查看当前设备的vrf以及有没有设备隶属于他

    一定是接口先划入vrf，再加ip
</code></pre><ol>
<li><p>完成c-network的配置</p>
</li>
<li><p>完成ce和pe间的路由信息共享</p>
</li>
<li><p>在pe设备上将vrf路由和mp-bgp路由进行双向重分发    </p>
<ol>
<li><p>静态、rip、eigrp、ospf、重分发进mp-bgp</p>
<p> 如果pe和ce上启用的是bgp，那么不需要重分发</p>
<pre><code>nei &lt;xxxx&gt; allowas-in x   //ebgp防环机制会阻挡路由从ce返回pe，此条命令为 允许学习所带自己as号几次

router bgp &lt;as-id&gt;
address-family ipv4 vrf &lt;name&gt;   //这里的vrf名字一定要对应到c-net
redistribute [&lt;static/eigrp as-id/ospf p-id&gt;]

show ip bgp vpnv4 all  //查看mp-bgp 路由转发表

show ip bgp vpnv4 all label  //查看栈底标签
</code></pre></li>
<li><p>bgp重分发进ospf需：</p>
<pre><code>redistribute bgp &lt;as-id&gt; subnets
</code></pre></li>
</ol>
</li>
</ol>
<ul>
<li><p>注意</p>
<p>  yntag在mpls vpn中会移除所有标签，这会引起数据无法传递，所以如果mpls vpn底层协议是ospf，loopback接口务必 </p>
<pre><code>ip ospf network point-to-point
</code></pre></li>
</ul>
<ul>
<li><p>RT的设置</p>
<p>  RT不管是出，还是入都可以是多个值</p>
</li>
</ul>
<h2 id="mpls-vpn中的ospf特性"><a href="#mpls-vpn中的ospf特性" class="headerlink" title="mpls vpn中的ospf特性"></a>mpls vpn中的ospf特性</h2><ol>
<li><p>ospf超级骨干层</p>
<p> 超级骨干层就是mpls vpn的p-network，pe设备扮演了abr，pe-net在帮助骨干层交换路由信息</p>
</li>
<li><p>pe设备和ce设备启用ospf的限制</p>
<ol>
<li><p>pe和ce间最好是ospf，区域0</p>
<p> pe和ce间如果不是区域0，那么pe只学习相连的ospf区域路由，其他区域路由不学习。这种情况下，pe和ce需要启用ospf的虚链路，来完成pe和ce间非区域0的路由信息共享工作</p>
</li>
</ol>
</li>
<li><p>ospf的路由信息通过p-net共享后的路由类型</p>
<ol>
<li>pe设备连接的相同区域ospf路由信息互换之后，反而是区域间路由</li>
<li>pe设备学习的不同区域的路由通过p-net交换后，依旧是区域间路由</li>
<li>pe设备学习的外部路由通过p-net交换后依旧是外部路由形式</li>
</ol>
</li>
<li><p>mpls vpn的back door路径和路由还原问题</p>
<ol>
<li><p>mpls vpn pe设备上配置sham-link（伪链路）</p>
<p> 伪链路帮助还原相同区域路由</p>
<p> pe配置伪链路，然后帮助pe连接的相同区域进行路由还原</p>
</li>
<li><p>隧道技术</p>
<ol>
<li><p>GRE TUNNEL 路由通用封装</p>
<p> GER通过管理员的配置，对数据额外的进行包头的添加封装。</p>
</li>
</ol>
<ul>
<li><p>补充知识</p>
<ol>
<li>rip，eigrp更新源就是下一跳</li>
<li>ospf更新源实际上是lsa的adv-id（通告者id，通常为该路由所在地的router-id），是溯源的</li>
<li>bgp跟新源判断：ebgp路由；ibgp路由</li>
<li>ospf路由更新开销会被MP-bgp携带，当作路由更新属性传递到对端</li>
</ol>
</li>
</ul>
<ol>
<li><p>伪链路的配置流程</p>
<ol>
<li>pe设备上创建隶属于vrf的loopback，添加ip地址，且掩码为255.255.255.255</li>
<li>pe设备上将划入vrf的环回接口的ip宣告进指定的vrf bgp</li>
<li><p>pe设备vrf ospf下完成伪链路设置</p>
<pre><code>router ospf 1 vrf x
area 0 sham-link &lt;自己环回口ip&gt; &lt;对端环回口ip&gt;
</code></pre></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="mpls-vpn-跨域"><a href="#mpls-vpn-跨域" class="headerlink" title="mpls vpn 跨域"></a>mpls vpn 跨域</h2><ol>
<li><p>跨域MPLS VPN的定义</p>
<p> C-NEWORK分布在不同的AS，需要交换路由信息，保障连通性。</p>
</li>
<li><p>实现跨域MPLS的办法</p>
<ol>
<li><p>back to back：背靠背方法 或者option A</p>
<ol>
<li><p>bgp关闭rt筛选功能，当前设备没有起用对应的vrf，但是希望mp-bgp接收vpnv4更新的网络</p>
<pre><code>router bgp x
no bgp default router-targetfilter
</code></pre></li>
<li><p>如果设备是mp-bgp的路由反射器，那么设备即便即使没有vrf，没有关闭rt筛选功能，一样学习接路由</p>
</li>
<li>asbr配置vrf，并且和对端asbr形成基于vrf的ebgp peer关系。（互相把对方当作c-net看）-&gt;这样r3就可以不配置关闭筛选功能了</li>
<li><p>注意： rt栈底标签是跟着mp-bgp更新发送出去的</p>
</li>
<li><p>back to back 背靠背跨域mpls vpn的技术特点</p>
<ol>
<li>ASBR都视对方为CE设备，和对方建立VRF的EBGP PEER关系</li>
<li>ASBR不需要相互启用LDP，也不需要MP-BGP</li>
<li>当前设备会给对端ASBR共享的路由一个新的本地栈底标签</li>
<li>数据通讯过程中，ASBR之间数据是不携带标签的，只是一个普通的IP包</li>
</ol>
</li>
</ol>
</li>
<li><p>option B 2A</p>
<p> ASBR上关闭RT 筛选：AS不要创建VRF，但是需要学习VPNV4路由更新。<br> ASBR上建立基于直连网络的MP-BGP对等体关系<br> ASBR对着各自AS内的IBGP PEER配置NEXT-HOP-SELF（在vpnv4下）</p>
<ol>
<li><p>注意</p>
<p> 此方案中，通过mp-bgp共享了各自as的栈底标签，那么两个asbr会将栈底标签关联，形成lsp，传递数据</p>
<p> ASBR会给各自AS内的BGP路由，重新分配一个栈底标签，共享到对端。</p>
<p> RD值会当做RT值走（关掉RT值筛选后）show  ip bgp vpnv4 all 8.8.8.8</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>3. option B 2B

    ASBR关闭RT筛选

    ASBR直连网络启用MPLS 

    ASBR对着对端LOOPBACK 0接口配置静态路由

    ASBR之间建立EBGP PEER 的MP-BGP关系

    1. 注意：ASBR对着各自AS内的RR配置NEXT-HOP-SELF或者将静态路由重分发进入底层协议。
    2. 2b和2a应用场景不同，2A ASBR之间必须直接链接，没有其他设备了。2B ASBR之间可以有其他若干设备，所以才需要MPLS，栈顶标签，帮忙穿越。


    ！！！要设置EBGP多跳（因为EBGP之间默认是1跳，用的是环回口）

        show ip bgp vpnv4 all
        show ip bgp vpnv4 all tabel

4. OPTION  C
    1. ASBR形成直连网络的EBGP  PEER关系，并且共享标签信息。
    2. ASBR上将各自AS的PE设备和RR设备lo 0接口而宣告进BGP
    3. 各自AS设备RR利用LOOPBACK接口创建BGP和MP-BGP PEER关系，MP-BGP  PEER 关系中设置NEXT-HOP-UNCHANGE(下一跳不改变)

        ！！EBGP PEER 间交换路由信息时，会改变下一跳地址，更新发送者会成为新下一跳，NEXT-HOP-UNCHANGE就是不允许改变下一跳地址。
    4. ASBR上将从对端学习的BGP路由重分发进底层。
    5. 注意

        1. send-label的作用

            关于下一跳的栈顶标签和目标网络的栈底标签都发送给对端BGP  PEER
        2. ASBR 间 常规BGP的作用

            宣告各自AS  PE 和RR的地址，让对方学习。

            目的是为了帮助RR利用地址建立MP-BGP  PEER 关系

            宣告PE的地址是为了 NEXT-HOP-UNCHANGE后，下一跳可达，也是为了对方将这个下一跳地址重分发进底层协议。
        3.     ASBR BGP 下设置权重

            目的是为了保障ASBR抵达对端路由，永远走正确的路径
        4. RR建立MP-BGP PEER关系和NEXT-HOP-UNCHANGE目的

            RR通常是P-NETWORK的核心设备，核心设备直接交换路由信息，再反射给PE

            NEXT-HOP-UNCHANGE为了让PE感受是在直接交换路由。
        5.    PE设备上将BGP路由重分发进IGPS

            目的是为了LDP给这些路由分配标签。
</code></pre><ol>
<li><p>跨域的MPLS  VPN总结</p>
<ol>
<li><p>ORTION  C：方法C</p>
<p>实际运用场景为特大运营网络，让P设备直接交换信息，而不是PE</p>
<ol>
<li>设置权重控制选路 </li>
<li>栈底标签sendlabel </li>
<li><p>栈顶标签用重分发解决</p>
<pre><code>口诀：

ASBR间常规BGP，宣告是为了RR（P设备）建立MP-BGP PEER关系
ASBR上WEIGHT设置是为了避免走错误路径
ASBR上SENDLABEL是为了将最终下一跳栈顶标签和原本的栈底标签共享出去
ASBR上将学习的对端PE网络路由重分发进底层，是为了底层的标签分配
</code></pre></li>
</ol>
<p>最终实现了PE看似和PE的路由信息直接共享，标签的关联。</p>
<p>特色：ASBR间没有MP-BGP   ASBR间没有MPLS</p>
<p>！！  mpls  bgp  forwarding  （让设备能处理带标签的数据，有的设备是配SENDLABEL自动出来的，有的设备没有）</p>
</li>
<li><p>OPTION B 2B</p>
<pre><code>ASBR上关闭RT筛选
ASBR 间启用MPL 
ASBR间启用MP-BGP PEER 关系（利用对端loopback接口，需要静态路由）
ASBR 对着RR做NEXT-HOP-SELF
</code></pre><p> 特色：ASBR间只要启用了MPLS，实际上ASBR不需要直连，有MPLS就可以帮助数据穿越路由黑洞</p>
</li>
<li><p>OPTION B 2A</p>
<pre><code>ASBR上关闭RT筛选
ASBR间启用MP-BGP PEER 关系（利用直连网络建立的BGP PEER 关系）
</code></pre><p> 特色：ASBR间没有MPLS，数据在ASBR间直接IP 包传递，所以ASBR间只能直连</p>
<ol>
<li><p>OPTION  A BACK TO BACK</p>
<p>  ASBR启用VRF，将对端当做CE<br>特色：ASBR间没有MPLS，数据在ASBR间也是IP包传递，只能直连</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><pre><code>mpls te
</code></pre>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2017/11/24/MPLS/" data-id="cjizrklev000m0gugkbiunjnb" class="article-share-link" data-share="baidu" data-title="MPLS">分享到</a>
      

      
        <a href="http://dmonster.top/2017/11/24/MPLS/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CCIE/">CCIE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CCNA" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/23/CCNA/" class="article-date">
  <time datetime="2017-09-23T11:48:28.000Z" itemprop="datePublished">2017-09-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/23/CCNA/">CCNA</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <h1 id="简单的流量操控"><a href="#简单的流量操控" class="headerlink" title="简单的流量操控"></a>简单的流量操控</h1><p>ACL 访问能控制链表 工作在在网络层和传输层</p>
<ul>
<li><p>标准acl 针对源ip 应用在接口之下，在每个接口针对每个方向的流量套用的acl只能用        一个</p>
<ul>
<li><p>配置：</p>
<pre><code>/*数字编号*/
 acc X(1-99) deny 源ip 反掩码
 int X(接口编号)
 ip acc X out/int
  /*命名*/
 ip acc standard X（名字）deny 源ip 反掩码
</code></pre></li>
</ul>
</li>
<li><p>扩展acl 针对协议（传输层，网络层），源ip，目的ip，端口号</p>
<ul>
<li><p>配置：</p>
<pre><code>/*数字编号*/
 acc X(100-199) deny 协议 源ip 反掩码 目的ip/目的网段 反掩码 端口号
 acc X(100-199) deny 协议 源ip 反掩码 host 主机ip  端口号
 acc X permit any any            
  /*命名*/
 ip acc extend X（名字）
</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>不管是何种acl最后都会存在一条拒绝所有数据的命令，一般都会在结尾加上一条放行所有命令行 </p>
<pre><code>acc X permint any
</code></pre><p>acl顺序不可调整 </p>
</li>
<li><p>删除</p>
<pre><code>no acc X
</code></pre></li>
<li><p>奇偶</p>
<pre><code>奇数acc 1 per 172.16.1.0 0.0.254.255
偶数acc 1 per 172.16.0.0 0.0.254.255
</code></pre></li>
</ul>
<h1 id="远程登录-telnet"><a href="#远程登录-telnet" class="headerlink" title="远程登录 telnet"></a>远程登录 telnet</h1><p>端口号：23  ，要求ping的通</p>
<pre><code>line vty 0 4 //0表示line从0开始，4表示一共有5个可供登录的单位

password X
</code></pre><p>同时配置，密文优先生效</p>
<h1 id="nat：地址转换协议"><a href="#nat：地址转换协议" class="headerlink" title="nat：地址转换协议"></a>nat：地址转换协议</h1><p>进行地址转换，可将私网地址转成公网地址进行通讯，提升了ip地址空间的使用率</p>
<ul>
<li>内部本地地址：内部主机所获得的私网地址</li>
<li><p>内部全局地址：转换成的公网地址</p>
<ul>
<li><p>配置方式</p>
<p>  一对一：静态的手动指定</p>
<ol>
<li><p>定义接口角色：</p>
<pre><code>int e0/0
ip nat inside

int e0/1
ip nat outside
</code></pre></li>
<li><p>进行地址映射的配置</p>
<pre><code>ip nat inside source static 私网内地址 公网出接口地址
</code></pre><p>多对多：动态的</p>
</li>
<li><p>定义接口角色</p>
</li>
<li><p>定义抓取要转换的流量</p>
<pre><code>acc 1 per 要转换的ip 反掩码8
</code></pre></li>
<li><p>定义转换后的地址</p>
<pre><code>ip nat pool ?（名字） 转换后的地址 netmask 子网掩码        
</code></pre></li>
<li><p>进行地址映射</p>
<pre><code>ip nat inside source list 1 pool ccnp
</code></pre><p>多对一：（目前用的最多的）端口号：区分主机</p>
</li>
<li><p>定义接口角色</p>
</li>
<li><p>定义要转换的地址流量</p>
</li>
<li><p>进行地址映射</p>
<pre><code>ip nat inside source list 1 int e0/0 overload  // e/0/0为出接口
</code></pre></li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h1><p>子接口： 将一个物理接口逻辑上划分成多个子接口使用，每一个划分出来的子接口和物理接口一样正常使用</p>
<pre><code>进入接口
no sh
int e0/0.X
en dot1q X(所要识别的标记)
</code></pre><h1 id="stp生成树协议"><a href="#stp生成树协议" class="headerlink" title="stp生成树协议"></a>stp生成树协议</h1><p>路由器单点故障（冗余）</p>
<ol>
<li>广播风暴</li>
<li>重复帧</li>
<li><p>mac地址表的不稳定</p>
<p> 解决方法：</p>
<ol>
<li>一个网络中选取一个根桥</li>
<li>根桥上所有端口都为指定端口</li>
<li>非根桥上选举一个根端口</li>
<li>每一段选取一个指定端口</li>
<li>非指定端口为阻塞端口</li>
</ol>
</li>
</ol>
<ul>
<li>bpdu：桥协议数据单元 （只允许根桥产生，不允许非根桥产生，毎2s发送一次，维护本生成树的运行）<ol>
<li>root id   = 优先级（默认为32768，越小越优，更改优先级时，优先级必须为4096的倍数 + 插进vlan信息数值） + 背板mac（表示交换机，越小越优）</li>
<li>桥id （发送者桥id） = 优先级 + 背板mac，设置与root id一样</li>
<li>cost</li>
<li>port id  = 优先级（默认为128，越小越优，更改时必须为64的倍数） + 端口mac（发送者的端口mac）</li>
</ol>
</li>
</ul>
<ul>
<li><p>pvst 毎vlan生成树</p>
<p>  若20s内没有收到bpdu信息则交换机将所有端口置于listen状态，<br>  tcn bpdu ：拓扑变更信息，从跟端口向上转发，根桥回复ack确认信息，由根桥向下所有人发送信息，全部重选</p>
<ol>
<li>block</li>
<li>init 初始化</li>
<li>listen 15s过后切入learn</li>
<li>learn  学习mac地址，完善mac地址表，15s后切入forword状态</li>
<li>forword</li>
</ol>
</li>
</ul>
<ul>
<li><p>端口</p>
<ul>
<li>指定端口：可以执行数据的转发，一台交换机上可以有多个指定端口（除跟端口和阻塞端口外，其余端口所有端口都为指定端口，根桥上所有端口都为指定端口）</li>
<li>根端口（只在非根桥上选举，并且只选以一个，为距离根桥路径最短的端口）</li>
<li><p>阻塞端口：逻辑上的阻塞，不执行数据的转发，但会持续侦听bpdu更新</p>
<pre><code>sh spanning sum
sh spa sum root port //查看谁是根
sh spa 
</code></pre></li>
</ul>
</li>
</ul>
<pre><code>span vlan 1,3,5,7,9 pri X（优先级值）

span vlan 1,3,5,7,9 root X（pri（主根）/sec（副根））（所有交换机优先级大于4096才可执行）
</code></pre><ul>
<li><p>rstp 快速vlan生成树</p>
<ul>
<li><p>端口：</p>
<ol>
<li>根端口</li>
<li>指定端口</li>
<li>阻塞端口</li>
<li>替代端口：替代根端口，从指定端口中选取</li>
<li>备份端口：备份的指定端口，从阻塞端口中选取</li>
</ol>
</li>
<li><p>状态：</p>
<ol>
<li>dis   丢弃状态： 周期性向外发送bpdu信息</li>
<li>learning  学习状态  一边侦听一边学习</li>
<li>forword  转发</li>
</ol>
</li>
<li><p>协商/同意机制</p>
<pre><code>特权模式下
spa mo rapid
</code></pre></li>
</ul>
</li>
<li><p>mst </p>
<p>  自动开启快速生成树（对快速生成树配置的优化），<br>  对vlan进行分组，一个组叫做一个实例（默认实例0）</p>
<pre><code>span mo mst 
span mst con
ins X(实例编号) vlan 1,2,3,4,5,6
</code></pre></li>
<li><p>portfast 快速端口/边缘端口</p>
<p>  将端口设为快速端口不参与生成树的选举之间进入到转发状态<br>  全局模式下</p>
<pre><code>spa port def //将交换机上所有端口都置于快速端口

接口下
spa port  //针对单一的接口开启
</code></pre></li>
<li><p>bpdu guard  bpdu保护</p>
<p>  置于快速的端口，若收到bpdu信息立马关闭，且必须管理员手动恢复（先sh，再no sh）</p>
<pre><code>全局模式下
spa por bpdug def

接口下
sw port mac-add mac地址    //绑定终端地址
</code></pre></li>
</ul>
<ul>
<li><p>接口角色</p>
<ul>
<li>inside：连接在内部广播域</li>
<li>outside：连接公网</li>
<li><p>配置：</p>
<pre><code>1.定义接口角色：
    int e0/0
    ip nat inside

    int e0/1
    ip nat outside
2.进行地址映射的配置
    ip nat inside source static 私网内地址 公网出接口地址
</code></pre></li>
</ul>
</li>
</ul>
<h1 id="DHCP：动态主机ip地址获得协议"><a href="#DHCP：动态主机ip地址获得协议" class="headerlink" title="DHCP：动态主机ip地址获得协议"></a>DHCP：动态主机ip地址获得协议</h1><pre><code>ip dhcp pool x（名字） 
network 地址段    //宣告将要分配的地址段
default-router 网关路由器地址

ip dhcp excluded-add //不向外分配的ip地址

/*指定分配ip*/
路由器上
ip dhcp pool X(名字)
host 将要分配的地址 子网掩码
def-ro 网关路由地址
client-iden 01mac地址（小数点向前移2位）

在主机上
int e0/0
ip add dhcp client-id e0/0
</code></pre><ul>
<li><p>dhcp中继</p>
<p>  由中继路由器收到的rarp广播请求发给dhcp服务器</p>
<pre><code>中继路由器上
ip help- add dhcp服务器地址
</code></pre></li>
<li><p>arp绑定</p>
<pre><code>arp 主机ip mac地址 arpa    
</code></pre></li>
</ul>
<h1 id="网关冗余协议"><a href="#网关冗余协议" class="headerlink" title="网关冗余协议"></a>网关冗余协议</h1><ul>
<li><p>GLBP</p>
<ul>
<li>思科私有，一个组最多可以有4台路由器</li>
<li>虚拟网关所对应的虚拟mac 0007.b400b.02xx </li>
<li>AVF：虚拟转发者</li>
<li>AVG：网关管理者，分配由哪一台路由器去承载该数据流量</li>
<li>优先级：默认100 越大越优</li>
<li><p>接口ip地址：越大越优</p>
<pre><code>sh gl bri
int e0/0
glbp X（组号） ip 虚拟网关ip地址 

glbp 1 pre  //开启抢占功能（所有路由器）

glbp 1 pri X（优先级）

glbp 1 load-bal round-robin(默认，依次)/host（固定的主机定向，固定线路）/wei（按比例分配流量）
glbp 1 wei X
</code></pre></li>
</ul>
</li>
<li><p>HSRP</p>
<ul>
<li>一个组中最多可以有12台路由器，组多只有一台转发，其他都为备份</li>
<li>虚拟网关ip所对应的虚拟mac 0000.0c07.acxx (xx为组号)</li>
<li>active：实际转发者</li>
<li>standby：备份路由器</li>
<li>优先级：默认100 越大越优</li>
<li><p>接口ip地址：越大越优</p>
<pre><code>standby X（组号） 虚拟网关
standby X pree  //开启抢占功能
standby X pri X（优先级）
sh sta bri
sta X tr 接口号 X（处罚值，当接口断开后从优先级上剪掉处罚值） //追踪接口
</code></pre></li>
</ul>
</li>
<li><p>VRRP    </p>
<p>  对应的虚拟mac 0000.5e00.01xx</p>
</li>
<li><p>接口状态：</p>
<ul>
<li>down：没有开启网关冗余协议协议</li>
<li>init：已开启，发送hello信息包</li>
<li>learn：开启网关冗余，但是没有设置虚拟ip，学习同组虚拟ip</li>
<li>listen：侦听hello信息包进行角色竞选</li>
<li>standby：持续侦听hello信息，一边确定网络中的active路由器是否还在，他的竞选参数跟本地相比是否更优</li>
<li>active：正常接收数据，转发，同时周期性的发送hello信息通告本地的存活状态及参数，毎2s发一次</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2017/09/23/CCNA/" data-id="cjizrkle300070gugua8oo6pz" class="article-share-link" data-share="baidu" data-title="CCNA">分享到</a>
      

      
        <a href="http://dmonster.top/2017/09/23/CCNA/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CCNA/">CCNA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NA测试题小综合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/10/NA测试题小综合/" class="article-date">
  <time datetime="2017-09-10T03:12:59.000Z" itemprop="datePublished">2017-09-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/10/NA测试题小综合/">NA测试题小综合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <p><img src="https://i.imgur.com/GgESZvp.png" alt=""></p>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><ol>
<li>.路由器R1是企业边界路由器，企业内部不运行任何的路由选择协议。 </li>
<li><p>公司内部有4台交换机，分别连接了公司的三个部门，分别是A部门B部门和C部门<br>，还有一个单独的公司网络管理者(vlan40)，要求部门与部门之间相互的独立，并且需要保持<br>，公司内部交换机设备配置的一致性。 </p>
<pre><code>A部门   192.168.1.0/24
B部门   192.168.2.0/24
C部门   192.168.3.0/24
网络管理者  192.168.10.0/24
</code></pre></li>
<li>公司内部所有的设备的远程管理都只能允许管理者一台PC访问。</li>
<li>路由器R1从ISP获得到一个公网IP地址，被分配在R1的串行接口上，公司</li>
<li>内部所有用户需要访问互联网的服务器(NAT) </li>
<li>A,B,C三个部门主机地址需要由R1动态分配</li>
<li>运营商内部是可以相互使用PING命令来测试网络连接性的，但是对于公司内部网络是不允许有任何的Ping数据包出现在公网之上的，但是不能影响到用户的正常数据。 </li>
<li>网络中有两台HTTP服务器，所有用户都可以访问HTTP服务器，但是C部门的用户不能访问HTTP2服务器  </li>
</ol>
<h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><ol>
<li><p>配置交换机的vl和trunk</p>
<p> 以sw1为例</p>
<pre><code>vtp do ccie
vtp mo se
vl 10
vl 20
vl 30

int ran f0/3,f0/4,f0/5
sw mo tr  //因为pt为思科模拟器所以不许选择trunk协议,trunk协议只需设置一边的接口即可
</code></pre><p> 以sw2为例划分vl</p>
<pre><code>int f0/1
sw acc vl 10
int f0/2
sw acc cl 20
</code></pre></li>
</ol>
<ol>
<li><p>配置dhcp协议</p>
<p> 在sw1上配置单臂路由</p>
<pre><code>int f0/24
sw mo tr
</code></pre><p> 在r1上划分子接口</p>
<pre><code>int f0/0.1
en dot1q 10
ip add 192.168.1.1 255.255.255.0

int f0/0.2
en dot1q 20
ip add 192.168.2.1 255.255.255.0

int f0/0.2
en dot1q 30
ip add 192.168.3.1 255.255.255.0
</code></pre><p> 在r1上配置dhcp协议</p>
<pre><code>ip dhcp pool v1
network 192.168.1.0 255.255.255.0
default-router 192.168.1.1  

ip dhcp pool v2
network 192.168.2.0 255.255.255.0
default-router 192.168.2.1

ip dhcp pool v3
network 192.168.3.0 255.255.255.0
default-roter 192.168.3.1
</code></pre></li>
<li><p>ospf配置</p>
<p> 在r1上配置ip并设置缺省路由</p>
<pre><code>ip route 0.0.0.0 0.0.0.0 se0/0/0
</code></pre><p> 配置ospf，以isp1为例</p>
<pre><code>int f0/0
ip add 202.195.12.1 255.255.255.252
ip os 1 a 0

int f0/1
ip add 202.195.12.2 255.255.255.252
ip os 1 a 0
</code></pre></li>
<li><p>http服务器配置</p>
<p> 配置http服务器ip，以ISP4的f0/1端口作为默认网关。<br> sw5上不做任何配置</p>
</li>
<li><p>访问控制链表配置</p>
<p> nat地址转换，将私网地址转换成公网地址</p>
<pre><code>acc 1 per 192.168.1.0 0.0.0.255
acc 1 per 192.168.1.0 0.0.0.255
acc 1 per 192.168.1.0 0.0.0.255
ip nat inside source list 1 int s0/0/0 overload
</code></pre><p> R1上s0/0/0端口</p>
<pre><code>acc 100 deny icmp any any echo
acc 100 per ip any any

int s0/0/0
ip acc 100 out
</code></pre><p> R1上的f0/0.3端口</p>
<pre><code>acc 101 deny tcp any host 202.195.40.2 eq www
acc 101 per ip any any

int f0/0.3
ip acc 101 in
</code></pre></li>
</ol>
<ol>
<li><p>vlan40 管理者</p>
<p> 管理者pc上配置地址为192.168.10.1 , 以SW1为例，在SW1上将f0/1配置</p>
<pre><code>int vl40
ip add 192.168.10.2 255.255.255.0

int f0/1
sw acc vl 40
no sh

测试SW1和管理者pc能ping通

enable password ccie //配置SW1交换机密码（也可以为密文）
line vty 0 4
passwoed 123  //配置管理者pc的telnet登录密码
</code></pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2017/09/10/NA测试题小综合/" data-id="cjizrklh600140gugt0z731hd" class="article-share-link" data-share="baidu" data-title="NA测试题小综合">分享到</a>
      

      
        <a href="http://dmonster.top/2017/09/10/NA测试题小综合/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CCNA/">CCNA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CCNP--交换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/14/CCNP--交换/" class="article-date">
  <time datetime="2017-08-14T08:26:59.000Z" itemprop="datePublished">2017-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/14/CCNP--交换/">CCNP--交换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><ul>
<li><p>交换机只用mac地址，接口上不支持ip配置</p>
</li>
<li><p>交换机处理广播数据帧的方式 ：泛洪，除接受端口外，所有端口都向外发<br>回复：单播包</p>
</li>
<li><p>广播域：广播信息能够传递到的最大范围</p>
</li>
<li><p>冲突域：发生冲突之后所影响的范围</p>
</li>
<li><p>CSMA/CD    载波帧听多链路访问，可缓解冲突，在通讯时同时向其他设备发送正在通讯信息</p>
</li>
</ul>
<ul>
<li><p>交换机指示灯</p>
<ul>
<li><p>绿色</p>
<p>  不闪：说明接口两端通讯没有问题，但是当前设备没有数据通过，<br>  不停的闪：说明这个接口正在接收和发送数据</p>
</li>
<li><p>橘红色</p>
<p>  慢闪：说明当前端口没有问题，但是连接端口的线路或者对端端口有问题<br>  快闪：接口和对端连接没问题，正在协商建立连接的参数</p>
</li>
<li><p>黄色</p>
<p>  闪动：物理接口有问题，尝试重启<br>  不闪：物理接口有问题，无法通信</p>
</li>
</ul>
</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li><p>将交换机的端口分为两种：access trunk</p>
</li>
<li><p>vlan：虚拟的局域网 sh vlan</p>
<p>  用来分隔管广播域，交换机中可以划分的端口为2-1001<br>  初始化状态下，所有接口属于vlan1（默认vlan，不允许删除）<br>  1002-4096：保留vlan不做分配</p>
<pre><code>在全局配置模式下
vlan 50 
name X（名字）

int f0/0
switch acc vlan 50
在交换网络中一个接口只能属于一个vlan

vlan data
vlan X（编号）
apply（或ex退出）
</code></pre></li>
<li><p>native vlan：本帧vlan（只在当trunk协议为802.1Q时存在）</p>
<p>  默认为1，一半不建议修改，若要修改保持本网络上本帧vlan设置一致</p>
<pre><code>sh int trunk

trunk接口下
switch trunk native vlan X
</code></pre></li>
<li><p>trunk：干道协议</p>
<ol>
<li>isl 思科私有协议（目前思科也不采用）通过在封装工作</li>
<li>802.1Q 通过tag </li>
</ol>
<ul>
<li><p>两端必须都为trunk</p>
<p>  int f0/0<br>  switch trunk enca X(isl/dot1q)  //选择trunk协议<br>  switch mode trunk </p>
</li>
</ul>
</li>
<li><p>trunk下vlan流量过滤</p>
<pre><code>trunk接口下
switch trunk all vlan 1-9,11-4094    //拒绝vlan10
</code></pre></li>
<li><p>vtp虚拟传输协议</p>
<ul>
<li><p>用于同步同一网络中交换机上vlan信息</p>
</li>
<li><p>将网络中的交换机选出一台作为服务器，其他交换机被动同步其中的vlan信息</p>
</li>
<li><p>生效的前提：trunk正常工作</p>
<p>模式</p>
<ol>
<li><p>server服务端：创建，修改，维护，传递，删除，同步vlan信息<br> 存储与nvram</p>
</li>
<li><p>client客户端：传递，同步vlan信息<br> 存储于ram</p>
</li>
<li><p>transparent透明模式：创建，修改，维护，传递，删除vlan，并且本地创建，修改，维护，删除的vlan信息只在本地有效，不会向外传递<br> 存储于nvram</p>
<p>vtp domain X<br>vtp mode server/client/trans</p>
</li>
</ol>
</li>
<li><p>sh vtp status //查找configuration revision配置修订号，若大，则其他交换机要同步本台的vlan</p>
</li>
<li>若要在网络中接入新的交换机，先设置成tans模式，查看其配置修订号，配置修订号只能加，不能减</li>
</ul>
</li>
</ul>
<h1 id="三层交换"><a href="#三层交换" class="headerlink" title="三层交换"></a>三层交换</h1><ul>
<li><p>企业连接运营商（isp）的方式</p>
<ul>
<li>单宿：从一个运营商拉一根线</li>
<li>多宿：从多个运营商每个运营商拉一根线</li>
<li>双宿：从同一个运营商拉多根线</li>
<li>双多宿：从多个运营商拉多根线</li>
</ul>
</li>
</ul>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><ul>
<li><p>svi端口</p>
<p>  虚拟的vlan接口，广播域的出口，不受物理接口的限制，只受整台交换机性能的限制，<br>  前提：本地存在vlan</p>
<pre><code>int vlan 10   //进入vlan10接口，只能识别vl 10 的流
</code></pre></li>
</ul>
<h2 id="EC-以太网链路聚合"><a href="#EC-以太网链路聚合" class="headerlink" title="EC:以太网链路聚合"></a>EC:以太网链路聚合</h2><p>企业园区网络中将整个企业网络分为三层</p>
<ul>
<li>核心层：服务器集群和出口路由器所在，与汇聚层之间用物理线连接多根，用EC技术逻辑上捆绑成一根，这跟线路集成了这些线路的性能总和<ul>
<li>使用前提<ul>
<li>所有接口物理性能必须保持一致</li>
<li>接口下所有配置必须相同</li>
<li>链路两端物理性能和配置保持一致</li>
</ul>
</li>
<li>汇聚层：与接入层之间的链路最少为万兆，可以进行数据的操控（分段，分组）</li>
<li>接入层：用户数据的接入，接入层设备（交换机）数量最多，性能最差，接入层连接的大部分为百兆网</li>
</ul>
</li>
</ul>
<h3 id="EC协议"><a href="#EC协议" class="headerlink" title="EC协议"></a>EC协议</h3><p>EC接口由两端协商建立，但是必须手动指定物理接口所属模式</p>
<ul>
<li>pagp：思科私有<ul>
<li>接口模式<ul>
<li>on：不协商，强制成为EC通道</li>
<li>auto：有意愿成为EC通道，但不主动协商（默认）</li>
<li>active：有意愿成为EC通道，主动发起协商</li>
<li>off：不成为EC通道</li>
</ul>
</li>
</ul>
</li>
<li><p>lacp：默认</p>
<pre><code>- on: on
- off: off
- passive:auto
- desirable:active

channel-pro 协议 
channel-group X（组号） mode 接口模式
int port-chan X(组号)
por-chan load-bal ?   //物理接口中如何进行流量分配
</code></pre></li>
</ul>
<p>每一台二层交换机可以配置一个ip地址（只能配一个）用来进行设备的管理，ip的配置启用在svi端口之下，配置ip的vlan叫做本台交换机的管理vlan</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2017/08/14/CCNP--交换/" data-id="cjizrklbo00000gugipdacmxm" class="article-share-link" data-share="baidu" data-title="CCNP--交换">分享到</a>
      

      
        <a href="http://dmonster.top/2017/08/14/CCNP--交换/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CCNP/">CCNP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CCNP--路由EGP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/14/CCNP--路由EGP/" class="article-date">
  <time datetime="2017-08-14T07:43:55.000Z" itemprop="datePublished">2017-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/14/CCNP--路由EGP/">CCNP--路由EGP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <h1 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h1><ol>
<li>属于EGP（边界网关）协议</li>
<li>全称：边界网关</li>
<li>工作类型：路径矢量路由选择协议</li>
<li>基于tcp连接（三次握手）</li>
<li><p>三张表</p>
<ul>
<li><p>邻居表   </p>
<pre><code>邻居关系建立的几种状态
idle：本地路由器向外发起tcp请求并等待恢复
connect：tcp连接已经建立
active：tcp连接建立不成功，在此状态下，会再次请求连接建立
opensend：在此状态下，会互相发送open信息，协商邻居关系的各项参数，并等待确认
openconfirm：收到对方的确认信息，进行参数对比，若失败，进入idl状态
establish：建立完成
keeplive：维持对等体关系的建立  60s发一次，180s收不到断开连接
</code></pre></li>
<li>bgp表</li>
</ul>
</li>
</ol>
<pre><code>    通过updata更新包互相发送路由更新条目，第一次更新完成后，不会周期性更新，只会增量更新或触发更新（将变化的内容发送出去）

- 路由表

       13条选路原则，需掌握6条
</code></pre><ol>
<li><p>为什么要使用bgp</p>
<ol>
<li>igp路由表只能容纳千条，bgp路由表中可容纳归纳上万条条目，可以支持庞大的网络规模</li>
<li>丰富的路径属性给我们提供了更为丰富的路由操控策略</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>对路由器的性能要求高</li>
<li>配置程序复杂            </li>
<li>一般情况下，小网络不建议使用bgp</li>
</ol>
</li>
<li><p>bgp AS定义：基于路由器，一台路由器只允许属于一个AS（1-65535）（私有AS 65412-65535）（公有AS 1-65411 IANA）</p>
</li>
<li><p>邻居类型</p>
<ul>
<li>iBGP：处于同一AS内的BGP路由器所建立的BGP对等体关系</li>
<li>eBGP：处于不同AS的BGP路由器所建立的对等体关系</li>
</ul>
</li>
<li><p>bgp的防环机制</p>
<p>AS-path</p>
<ul>
<li>bgp对等体路由器收到ibg路由不会发给其他ibgp对等体关系</li>
<li>bgp路由器收到ebgp路由时会原封不动的传给其他路由器</li>
</ul>
</li>
<li><p>bgp路由黑洞</p>
<p>bgp路由更新是单播的，基于tcp目标端口179发送的，路由更新的源ip是本地或指定的，目标ip是nei后边跟着的地址，沿途设备如果没有参与bgp，只是将是举报视为常规数据发给目的地，传递更新的设备委比学习路由，但却会成为路径沿途中必须经过的下一跳，这就是路由黑洞</p>
<ul>
<li>解决方法<ol>
<li>重分发（一版不建议）</li>
<li>全互联的网络拓扑（两两之间建立bgp关系）</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>路由来自于ebgp，bgp路由如何处理</p>
<p>  当前设备会关注更新懈怠的as-path信息，判断是否有环路存在</p>
</li>
<li><p>路由来自于ibgp，bgp如何处理</p>
<ol>
<li>bgp先判断同步开否，如果开了，bgp要求更新网路必须满足同步要求，否则不学习，同步是指接收bgp更新的路由器，不光bgp学习该网络，当前设备所处的as底层协议也需要学习，同步是为了避免黑洞，但是同步却要被关闭，因为底层协议的管理距离小于ibgp的管理距离，最终会取代bgp</li>
<li><p>bgp判断来自于ibgp peer的路由更新下一跳，并且要确认下一跳可达</p>
<ol>
<li>路由更新来自于as外，路由更新通告者是ebgp peer，那么下一跳就是ebgp peer。</li>
<li>路由更新源自于as外，路由更新通告者却是ibgp peer，那么下一跳还是ebgp peer。</li>
<li><p>路由更新来自于as内，路由更新通告者是ibgp peer，那么下一跳还是ibgp peer。</p>
<p>经常判断出下一跳就是ebgp peer地址，但是下一跳不可大，所以才需要配置next-hop-self</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<ol>
<li>bgp错误信息通告： notification</li>
</ol>
<h2 id="BGP的基本配置"><a href="#BGP的基本配置" class="headerlink" title="BGP的基本配置"></a>BGP的基本配置</h2><pre><code>sh ip bgp sum
</code></pre><ol>
<li><p>对等体关系的建立 （邻居表）</p>
<ol>
<li><p>所有对等体关系必须互相手动指定并且制定的地址必须可达 </p>
<pre><code>router bgp X（as号）
nei ip地址（必须可达）remote-as ？（对端as号）
</code></pre></li>
<li><p>环回口建立时，一段必须指定更新源，建议两端都指定 </p>
</li>
</ol>
</li>
</ol>
<pre><code>    用环回口建稳定性好，不会出故障，若到达环回口有多条路径可达，其中一条断开，不会影响bgp对等体关系的建立，问题：源地址参数不对，解决放法：手动指定更新源（指定一端即可）一般不建议使用环回口建立ebgp协议

        nei ip地址（必须可达）updata-so 更新源接口

- bgp路由器用环回口建立ibgp对等体关系时， bgp路由器赋予open信息包ttl值为255
- bgp路由器用环回口建立ebgp对等体关系时， bgp路由器赋予open信息包ttl值为1  （手动设置ttl值：ebgp多跳，两端都要设置 ）

        nei 环回口ip edgp-mul X（ttl值）
</code></pre><ol>
<li><p>BGP表的建立</p>
<pre><code>sh ip bgp
</code></pre><ul>
<li><p>内部条目通过宣告或者重分发带入所得</p>
<pre><code>bgp宣告的条目可以使本地直连网段，也可以是本地通过IGP协议所学到的网段，即宣告的网段必须存在于本地路由表中

  net 网段 mask 子网掩码
</code></pre><p>  bgp表中下一跳地址为0.0.0.0 代表这条路由起源于本地</p>
</li>
<li><p>网络边界，往内做 </p>
<pre><code>nei ip地址 next-hop-self
</code></pre></li>
</ul>
</li>
<li><p>路由反射器（RR路由器）</p>
</li>
</ol>
<pre><code>nei ip地址 router-reflected-clier
</code></pre><ol>
<li><p>清除</p>
<pre><code>clear ip bgp * //硬清除：拆除tcp连接重新建立
clear ip bgp * soft //软清除：清除路由更新
</code></pre></li>
<li><p>聚合（汇总）</p>
<p> 起源于本地的路由不能聚合</p>
<pre><code>router bgp X
aggregate-address 聚合后的网段 聚合后的子网掩码 （summary—only 只发送聚合后的路由）
</code></pre></li>
<li><p>用对等体组建立bgp对等体关系</p>
<pre><code>router bgp X
nei 组名 peer-group    //创建对等体组
nei ip peer-group 组名    //加入组
</code></pre></li>
</ol>
<h2 id="bgp选路原则"><a href="#bgp选路原则" class="headerlink" title="bgp选路原则"></a>bgp选路原则</h2><ol>
<li><p>weight 权重值（cisco私有）   越大越优   </p>
<pre><code>sh ip bgp 
</code></pre><ol>
<li>权重值只在本地有效，影响本地的选路</li>
<li>默认权重值<ul>
<li>起源于本地的路由条目默认权重：32768<ul>
<li>通过bgp学习到的路由条目默认权重值为：0</li>
</ul>
</li>
</ul>
</li>
<li><p>更改</p>
<pre><code>1.
router bgp X
    nei ip地址 wei X（权重值+X）

2.
route-map we pe 10
   set wei 10 
   router bgp X
nei ip地址 router-map we in 
</code></pre></li>
</ol>
</li>
</ol>
<ol>
<li><p>localpreference 本地优先级（默认100）</p>
<p> 只在同一个AS内生效，影响的是本地AS到外部的选路，默认优先级为100 优先级越大越优</p>
<pre><code>1.
router bgp X
bgp defa local-prefer X（优先级值）

route-map locaper per 10
set local-per X（优先级值）
</code></pre></li>
</ol>
<ol>
<li><p>起源于本地的路由（与权重值冲突）    无法修改</p>
</li>
<li><p>as-path </p>
<p> 路径短的优先，修改时只能加不能减，并且只能在ebgp对等体关系之间进行修改</p>
<pre><code>in 加在本来AS的后面（左面）
out加在本来AS的前面（右面）

route-map aspath per 10
set as-path prend X（as号）
</code></pre></li>
<li><p>起源代码</p>
<p> 在起源路由器上通过宣告得到的路由的起源属性 i,<br> 通过重分发得到的路由的起源属性 X ,i优于X</p>
<pre><code>route-map origin per 10
set origin incommple
</code></pre></li>
<li><p>med值（metric）</p>
<ul>
<li>影响相邻AS到本AS的选路</li>
<li>越小越优</li>
<li>默认情况下metric都为空即0</li>
<li>建议在出方向上做</li>
<li><p>起源属性优于med值</p>
<pre><code>route-map med per 10
set metric 100
</code></pre></li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2017/08/14/CCNP--路由EGP/" data-id="cjizrklea000a0gugjcue0pke" class="article-share-link" data-share="baidu" data-title="CCNP--路由EGP">分享到</a>
      

      
        <a href="http://dmonster.top/2017/08/14/CCNP--路由EGP/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CCNP/">CCNP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CCNP--路由IGP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/16/CCNP--路由IGP/" class="article-date">
  <time datetime="2017-07-16T08:05:35.000Z" itemprop="datePublished">2017-07-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/16/CCNP--路由IGP/">CCNP路由IGP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <h1 id="静态配置"><a href="#静态配置" class="headerlink" title="静态配置"></a>静态配置</h1><p>网络管理员手动添加  小型规模网络  维护成本高  不能灵活变通</p>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>连接方式     连接网段/网络位位数 [管理距离/metric值] via 下一跳地址, 已连接时间, 本地出接口</p>
<ul>
<li>管理距离：路由的可信度 值越小，越可信</li>
<li>metric值：开销/成本 以跳数计算</li>
</ul>
<h2 id="配置语句"><a href="#配置语句" class="headerlink" title="配置语句"></a>配置语句</h2><pre><code>ip route 目的地网段 目的地的子网掩码 下一跳地址
ip route 目的地网段 目的地的子网掩码 本地出接口
</code></pre><p>两种方式同时配置，接口方式优先生效</p>
<h2 id="源ip与目的ip"><a href="#源ip与目的ip" class="headerlink" title="源ip与目的ip"></a>源ip与目的ip</h2><p>默认情况下路由器会选择到达该目的地流量发出的接口ip为数据包的源ip<br>回复时源ip为发送数据的目的ip 目的ip为发送数据的源ip</p>
<h1 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h1><h2 id="路由环路解决方法"><a href="#路由环路解决方法" class="headerlink" title="路由环路解决方法"></a>路由环路解决方法</h2><p>（所有路由器上默认开启）</p>
<ol>
<li>水平分割 路由条目从本地路由器端口发出去，本地路由器的这个端口不会再接收该路由条目</li>
<li>路由毒化 将网络跳数设置成16  （跳数限制：数据在网络中最多经过16跳）</li>
<li>毒性反转 （不遵守水平分割原则）将毒性发给本地路由器发送的路由条目</li>
<li>hold-down倒计时 240s</li>
</ol>
<h2 id="汇总机制"><a href="#汇总机制" class="headerlink" title="汇总机制"></a>汇总机制</h2><p>简化路由表<br>172.16.1.0/24 - 172.16.100.0/24 -&gt;172.16.0.0/16<br>所有的路由器会自动将子网汇总成主类网络向外发</p>
<h2 id="被动接口-passive-interfacce-："><a href="#被动接口-passive-interfacce-：" class="headerlink" title="被动接口(passive-interfacce)："></a>被动接口(passive-interfacce)：</h2><p>只接受更新，不发送</p>
<pre><code>router rip
pas 接口
</code></pre><h2 id="单播更新"><a href="#单播更新" class="headerlink" title="单播更新"></a>单播更新</h2><p>指定更新的接受者</p>
<pre><code>router rip
ne 接口地址
</code></pre><h2 id="路由选择原则："><a href="#路由选择原则：" class="headerlink" title="路由选择原则："></a>路由选择原则：</h2><ol>
<li>最长匹配原则：网络位最长</li>
<li>若到达同一目的地通过不同的协议收到路径，优选管理距离小的</li>
<li>若到达同意目的地通过相同的协议收到路径，优选metric值小的</li>
</ol>
<h2 id="5k值（metric值）"><a href="#5k值（metric值）" class="headerlink" title="5k值（metric值）"></a>5k值（metric值）</h2><ol>
<li>带宽 ：物理接口的最大传输速率 =10^7/所经路径中最小带宽*256 kbit/s</li>
<li>负载 ：所能承载最大数据量</li>
<li>延迟 ：延迟 =所经路径产生的延迟总和/10*256 us</li>
<li>有效性 ：有效性（保质期，TTL值：最大能够经过多少台路由器，毎经过一台路由器ttl值-1）</li>
<li>mtu值 ：mtu值：每一个数据包中最大能包含多少字节</li>
</ol>
<h2 id="router-id"><a href="#router-id" class="headerlink" title="router-id"></a>router-id</h2><p>在本网络中对本台设备的标识</p>
<ol>
<li>若本地无环回接口则比较物理地址的大小，大的作为本地路由器的router-id</li>
<li>若本地有环回接口有限选用环回接口地址最为本台路由器的router-id<br>若有多个环回接口选取地址大的</li>
</ol>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul>
<li>自制系统（as）：处于同一管理机制下的路由器</li>
<li>lgp： 内部网管路由选择协议（管理距离） rip（120） eigrp（内部路由90 外部路由170） ospf（110）</li>
<li>egp： 边界网管路由选择协议（管理距离） bgp（内部200 外部20）</li>
</ul>
<h3 id="rip协议"><a href="#rip协议" class="headerlink" title="rip协议"></a>rip协议</h3><ul>
<li>最多16台路由器，只适用于小型</li>
<li>网络中</li>
<li>距离矢量路由选择协议</li>
<li>版本v1（ipv4，不支持vlsm子网掩码，不支持认证，不支持手动汇总），v2（ipv4，支持vlsm子网掩码，支持认证，支持手动汇总），ng（ipv6）</li>
<li>毎30s发一次路由更新，v1以广播形式广播地址发送   v2加进一组，组播地址224.0.0.9（组播更新）</li>
<li>rip路由更新线路不通时，先敬如180s等待，若之后的240s后还没恢复，则删除路由条目</li>
<li>rip认证<ul>
<li>明文：向外发送密钥时，只会发送编号最小的密码</li>
<li>密文：将所有编号的密码都向外发送</li>
</ul>
</li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul>
<li>在全局模式下输入 router rip 进入协议进程配置模式</li>
<li>输入 net 本地直连网络（有类网络） 1.0.0.0  宣告本地直连的网段</li>
<li>deb ip rip 显示rip动态信息</li>
<li>router rip ？ 配置rip版本</li>
<li><p>在接口下</p>
<pre><code>ip rip send version 1/2 发送什么类型的更新
ip rip receieve version 1/2 接收什么类型的更新
</code></pre></li>
</ul>
<h3 id="eigrp协议"><a href="#eigrp协议" class="headerlink" title="eigrp协议"></a>eigrp协议</h3><ol>
<li>工作类型：高级距离矢量路由选择协议</li>
<li>思科私有协议</li>
<li>能保证路由选择100%无环（DUAL算法）</li>
<li>支持vlsm</li>
<li>支持组播和单播更新</li>
<li>支持自动汇总和手动汇总</li>
<li>快速收敛（路由表的更新）</li>
<li>支持认证</li>
<li>eigrp中一个路由器可以属于多个as，但每个接口只能属于一个as</li>
<li>eigrp消息类型：<ul>
<li>hello信息</li>
<li>更新信息</li>
<li>ack确认信息</li>
<li>查询信息<br>-查询恢复</li>
</ul>
</li>
<li>汇总<ul>
<li>自动汇总</li>
<li>手动汇总</li>
</ul>
</li>
</ol>
<ul>
<li>邻居表 :毎5s以组播地址（224.0.0.10）向外发送hello包询问当前网络是否有同伴存在建立邻居关系<ul>
<li>前提条件：1.能互相收到hello包（直连），2.处于同一AS之内  3. 5k值要匹配（eigrp 5k值默认10100）</li>
</ul>
</li>
<li>拓扑表 ：包含邻居发给我的所有更新条目<ul>
<li>ad 通告距离 ：下一跳路由器到达目的地的距离</li>
<li>fd 可行距离 ：本地路由器到达目的地的距离</li>
<li>fs 可行条件 ：能被路由器选为可行路径需要符合的条件 ad &lt; 最小fd</li>
<li>sus 后继者 ：最优路径 （满足可行条件）</li>
<li>fsus 可行后继者 ：次优路径  （也必须满足可行条件）</li>
</ul>
</li>
<li>路由表</li>
</ul>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><pre><code>router ei ?(as号)
net 1.0.0.0
</code></pre><ul>
<li><p>精确宣告</p>
<ul>
<li><p>通配符（反掩码）： 0精确匹配，1不匹配 </p>
<p>  net 172.16.1.0 0.0.0.255</p>
</li>
</ul>
</li>
<li><p>手动汇总</p>
<pre><code>no auto  //关闭自动汇总
</code></pre></li>
<li><p>负载均衡    </p>
<ul>
<li>等价负载均衡：metric值一样</li>
<li><p>不等价负载均衡 ：将可行后继放进路由表中</p>
<pre><code>router ei 1
va X    //修改倍数因子
</code></pre></li>
</ul>
</li>
<li><p>末结区域</p>
<pre><code>不接受查询信息，
不连接其他任何网段，末结区域的路由器只关心本地是否能够向外通信

router ei 1
eigrp stub
</code></pre></li>
</ul>
<h3 id="ospf协议"><a href="#ospf协议" class="headerlink" title="ospf协议"></a>ospf协议</h3><p>开放最短路径优先</p>
<ul>
<li>链路状态路由选择协议</li>
<li>lsa数据包（11种）</li>
<li>邻接关系：逻辑上连接（在同一网络中）</li>
<li>骨干区域，非骨干区域 ： 非骨干区域之间的通信必须经过骨干区域（非骨干区域必须跟骨干狳直接相连）</li>
<li><p>DR指定路由器/BDR备份指定路由器/DRother其他路由器：（只有在刚播网络中才会竞选）</p>
<ul>
<li><p>优先级：越大越好 默认1  -255   设为0不称为DR/BDR</p>
<pre><code>int e0/1
ip os pr X  //修改优先级值
</code></pre></li>
<li>接口ip：大—DR</li>
<li>所有的路由器与DR与BDR之间建立邻接关系，DRother之间不建立任何邻接关系，他们一直处于two-way状态，DRother将所有更新条目发送给DR和BDR，DR和BDR汇总完成后再下发给DRother</li>
</ul>
</li>
<li><p>虚链路 中间只能横跨一个区域 一条骨干上虚链路只能有一个</p>
<pre><code>router os 1
ar X（需要穿过的区域） vir X（对方router-id）
</code></pre></li>
<li>邻居表</li>
<li>lsdb链路状态数据库 dbd数据库描述 sh ip os databse </li>
<li><p>cost开销值（受带宽影响）在接口下ip os cost X在接受方向上改变</p>
<pre><code>带宽          cost=metric 
10            100
100            19
1000        4
10000        2
</code></pre></li>
<li><p>消息类型</p>
<ul>
<li>hello</li>
<li>bdb</li>
<li>lsr链路状态查询</li>
<li>lsu链路状态更新</li>
<li>lsack链路状态确认</li>
</ul>
</li>
<li><p>lsa链路状态通告</p>
<ul>
<li>1类：router lsa （路由器lsa）区域内所有路由器都会自行产生一条，其中包含本地所有参与ospf的接口，ip，开销链路类型，等物理信息。只会在本区域内传递，不能穿过ABR</li>
<li>2类：network lsa （网络lsa）由DR产生，在本区域内传递，通告本段链路所能到达的所有路径。  O</li>
<li>3类：network summary lsa（网络汇总lsa）由ABR产生，向其他区域通告本区域的路径信息。通告范围：AS，即所有启用ospl的其他区域（本区域和特殊区域除外）   O IA</li>
<li>4类：ASBR汇总lsa 由ABR产生，向其他区域通告本区域中的ASBR是谁</li>
<li>5类：外部路径lsa 由ASBR产生，向ospf自制系统中通告外部路径 产生的路由类型O E2：在ospf自制系统中的传递开销值不会叠加 默认20 ； O E1: 在ospf自制系统中传递叠加开销值 ，若同时有OE1和OE2的路由存在优选OE1</li>
<li>7类：NSSA区域中的外部路径lsa ON2不叠加开销值；ON1叠加开销值</li>
</ul>
</li>
<li><p>特殊区域   </p>
<ul>
<li>stub 末结区域 ：身后不连接其他任何自制系统，但可以正常接收        ospf中其他区域的路由条目。123传递，457不传递</li>
<li><p>totally stup 完全末结区域：身后不连接其他任何自制系统，也不接               收ospf中其他区域路由条目。</p>
<pre><code>area X stub //末结
area X stub no-summary //完全末结
</code></pre><ul>
<li>由ABR向末结和完全末结区域内下发一条缺省路由以作通信（下一跳为ABR）</li>
</ul>
</li>
<li>nssa    末梢区域：可以传递外部路由（7类lsa））（缺省路由）</li>
<li><p>totally nssa 完全末梢区域：可以传递外部路由（7类lsa））（缺省路由）</p>
<pre><code>area X nssa //末梢
area X nssa no-summary //完全末梢
</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>ospf中接口网络类型    sh ip os int X（接口编号）</p>
<ol>
<li>广播：所有的以太网默认都是广播类型的</li>
<li>点到点：只有一个邻居的存在（串口默认）   接口下 ip os net point-to-point</li>
<li>NBMA ：非广播型多链路访问 （帧中继）</li>
<li>点到多点</li>
</ol>
</li>
<li><p>ospf默认所有环回口地址都为主机地址/32  —-改成点到点变正常</p>
</li>
</ul>
<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><ul>
<li><p>接口下</p>
<pre><code>ospf X area 区域号
</code></pre></li>
<li><p>ospf进程下</p>
<pre><code>router ospf X（进程号）
net 12.12.12.0 0.0.0.255 area X（区域号0为骨干区域，其他都为非骨干区域）宣告必须携带反掩码
</code></pre></li>
<li><p>重置ospf</p>
<pre><code>clear os pr
</code></pre></li>
<li><p>汇总（针对区域，外部汇总）</p>
<ol>
<li><p>ospf自制系统内的区域汇总（ABR上）</p>
<pre><code>router ospf ？（进程id）
area ？ range 汇总后的网段 汇总后网段的子网掩码
</code></pre></li>
<li><p>ospf外部路由的汇总（ASBR上）</p>
<pre><code>summary-address 汇总后的网段 汇总后网段的子网掩码
router os 1
re co su
</code></pre></li>
</ol>
</li>
<li><p>认证</p>
<ol>
<li><p>区域认证</p>
<pre><code>router os X
明文 area 1 au        
密文 area 1 au message 
</code></pre><p>到该区域的接口下配置密码</p>
</li>
<li><p>接口认证</p>
<pre><code>明文 ip ospf au-key key X(密码)
密文 ip ospf au message
    ip ospf messsafe key X(密码) md5
</code></pre></li>
</ol>
</li>
</ul>
<h3 id="重分发"><a href="#重分发" class="headerlink" title="重分发"></a>重分发</h3><ul>
<li><p>其他路由选择协议进rip</p>
<pre><code>router rip
redistribute 协议 metric X（metric值，默认为0 ）
</code></pre></li>
<li><p>其他路由选择协议进erigrp</p>
<pre><code>router ei ?
re 协议 metric 10000带宽 100延迟 255可靠值 1负载 150mtu
</code></pre></li>
<li><p>其他路由选择协议进ospf</p>
<pre><code>router os 1
red 协议 sub （metric-type X）（metric ？）
</code></pre></li>
<li><p>connected：直连</p>
</li>
<li>双向重分发：两个协议都能收到互相的路由信息</li>
</ul>
<h1 id="用路由器模拟pc机"><a href="#用路由器模拟pc机" class="headerlink" title="用路由器模拟pc机"></a>用路由器模拟pc机</h1><pre><code>接口下no ip route
</code></pre><h1 id="配置网关"><a href="#配置网关" class="headerlink" title="配置网关"></a>配置网关</h1><pre><code>ip de-ga 网关地址    
</code></pre>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2017/07/16/CCNP--路由IGP/" data-id="cjizrklel000f0gug733hb8fq" class="article-share-link" data-share="baidu" data-title="CCNP路由IGP">分享到</a>
      

      
        <a href="http://dmonster.top/2017/07/16/CCNP--路由IGP/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CCNP/">CCNP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BeautifulSoup库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/23/BeautifulSoup库/" class="article-date">
  <time datetime="2017-04-23T02:33:44.000Z" itemprop="datePublished">2017-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python3/">python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/23/BeautifulSoup库/">BeautifulSoup库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <p>若有如下html：</p>
<pre><code>html = &quot;&quot;&quot;
&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;
&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were
&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,
&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and
&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;
and they lived at the bottom of a well.&lt;/p&gt;
&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;
&quot;&quot;&quot;
</code></pre><h1 id="四大对象种类"><a href="#四大对象种类" class="headerlink" title="四大对象种类"></a>四大对象种类</h1><p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种</p>
<pre><code>soup = BeautifulSoup(open(&apos;index.html&apos;))
print soup.prettify() //格式化输出
</code></pre><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>注释为输出结果</p>
<ul>
<li><p>.descendants<br>descendants 属性可以对所有tag的子孙节点进行递归循环</p>
<pre><code>for child in soup.descendants:
    print child
//返回所有子孙节点
</code></pre></li>
<li><p>.content</p>
<pre><code>print soup.head.content
[&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;]
</code></pre><p>  返回的是一个list，用列表索引来获取它的摸一个元素：</p>
<pre><code>&gt;&gt;&gt;print soup.head.contents[0]
&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;
</code></pre></li>
<li><p>.children</p>
<pre><code>print soup.body.children
&lt;listiterator object at 0x7f71457f5710&gt;
</code></pre><p>  返回的是一个list生成器对象，循环遍历：</p>
<pre><code>&gt;&gt;&gt;print soup.body.children:
    print child

&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;

&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were
&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,
&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and
&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;
and they lived at the bottom of a well.&lt;/p&gt;

&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;
</code></pre></li>
<li><p>.patents</p>
<pre><code>content = soup.head.title.string
for parent in  content.parents:
    print parent.name

title
head
html
[document]
</code></pre></li>
<li><p>.next_sibling<br>  后一个兄弟节点</p>
</li>
<li><p>.previous_sibling</p>
<p>  前一个兄弟节点</p>
</li>
<li><p>print soup.title</p>
<pre><code>&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;
</code></pre></li>
<li><p>print soup.head</p>
<pre><code>&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;
</code></pre></li>
<li><p>print soup.a</p>
<pre><code>&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;
</code></pre></li>
<li><p>print soup.p</p>
<pre><code>&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;
</code></pre><ul>
<li><p>print soup.p.attrs    // 得到字典</p>
<pre><code>{&apos;class&apos;: [&apos;title&apos;], &apos;name&apos;: &apos;dromouse&apos;}
</code></pre></li>
<li><p>print soup.p[‘class’] 或 print soup.p.get(‘class’)</p>
<pre><code>[&apos;title&apos;]
</code></pre><h2 id="NavigableString"><a href="#NavigableString" class="headerlink" title="NavigableString"></a>NavigableString</h2></li>
</ul>
</li>
<li><p>.string</p>
<pre><code>print soup.p.string   // 得到内容但只有第一条
The Dormouse&apos;s story
</code></pre></li>
<li><p>.strings</p>
<pre><code>&gt;&gt;&gt;for string in soup.strings:
       print(repr(string))

u&quot;The Dormouse&apos;s story&quot;
u&apos;\n\n&apos;
u&quot;The Dormouse&apos;s story&quot;
u&apos;\n\n&apos;
u&apos;Once upon a time there were three little sisters; and their names were\n&apos;
u&apos;Elsie&apos;
....
</code></pre></li>
<li><p>.stripped_strings</p>
<pre><code>&gt;&gt;&gt;for string in soup.stripped_strings:
        print(repr(string))

// 作用和 .strings一样但是不输出空白行和空格
</code></pre><p>BeautifulSoup 对象表示的是一个文档的全部内容.大部分时候,可以把它当作 Tag 对象，是一个特殊的 Tag，我们可以分别获取它的类型，名称，以及属性来感受一下</p>
<blockquote>
<blockquote>
<blockquote>
<p>print type(soup.name)<br>   <type 'unicode'=""><br>print soup.name<br>   [document]<br>print soup.attrs<br>   {} 空字典</type></p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h2><p>Comment 对象是一个特殊类型的 NavigableString 对象，其实输出的内容仍然不包括注释符号，但是如果不好好处理它，可能会对我们的文本处理造成意想不到的麻烦。</p>
<h1 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h1><ul>
<li><p>find_all( name , attrs , recursive , text , keyword )</p>
<p>  find_all() 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件</p>
<ul>
<li><p>name参数</p>
<p>  name 参数可以查找所有名字为 name 的tag,字符串对象会被自动忽略掉</p>
<ol>
<li><p>字符串</p>
<pre><code>&gt;&gt;&gt;soup.find_all(&apos;b&apos;)
 [&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;]
</code></pre></li>
<li><p>正则表达式</p>
<pre><code>for tag in soup.find_all(re.compile(&quot;^b&quot;)):
    print(tag.name)

body
b
</code></pre></li>
<li><p>传列表</p>
<p> 返回列表</p>
</li>
<li><p>传True</p>
<p> True 可以匹配任何值,查找到所有的tag</p>
</li>
<li><p>传方法</p>
<p> 如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数 ,如果这个方法返回 True 表示当前元素匹配并且被找到,如果不是则反回 False</p>
</li>
</ol>
</li>
<li><p>keyword参数</p>
<pre><code>&gt;&gt;&gt;soup.find_all(id=&apos;link2&apos;)
 [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]
</code></pre><p>  在这里我们想用 class 过滤，不过 class 是 python 的关键词，这怎么办？加个下划线就可以</p>
<pre><code>&gt;&gt;&gt;soup.find_all(&quot;a&quot;, class_=&quot;sister&quot;)
 [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]
</code></pre></li>
<li><p>text参数</p>
<p>  通过 text 参数可以搜搜文档中的字符串内容.与 name 参数的可选值一样, text 参数接受 字符串 , 正则表达式 , 列表, True</p>
<pre><code>&gt;&gt;&gt;soup.find_all(text=&quot;Elsie&quot;)
 [u&apos;Elsie&apos;]
</code></pre></li>
<li><p>limit参数</p>
<p>  find_all() 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果.</p>
<pre><code>&gt;&gt;&gt;soup.find_all(&quot;a&quot;, limit=2)
[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]
</code></pre></li>
<li><p>recursive参数</p>
<p>  调用tag的 find_all() 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False .</p>
</li>
</ul>
</li>
</ul>
<h1 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h1><p>我们在写 CSS 时，标签名不加任何修饰，类名前加点，id名前加 #，在这里我们也可以利用类似的方法来筛选元素，用到的方法是 soup.select()，返回类型是 list</p>
<ul>
<li><p>通过标签名查找</p>
<pre><code>print soup.select(&apos;title&apos;)
print soup.select(&apos;a&apos;)
</code></pre></li>
<li><p>通过类名查找</p>
<pre><code>print soup.select(&apos;.sister&apos;)
print soup.select(&apos;#link1&apos;)
</code></pre></li>
<li><p>组合查找</p>
<pre><code>print soup.select(&apos;p #link1&apos;)
</code></pre></li>
<li><p>直接子标签查找</p>
<pre><code>print soup.select(&apos;head &gt; title&apos;)
</code></pre></li>
<li><p>属性查找</p>
<p>  查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。</p>
<pre><code>print soup.select(&apos;a[href=&quot;http://example.com/elsie&quot;]&apos;)
print soup.select(&apos;a[class=&quot;sister&quot;]&apos;)
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2017/04/23/BeautifulSoup库/" data-id="cjizrkled000c0gugiwaoratt" class="article-share-link" data-share="baidu" data-title="BeautifulSoup库">分享到</a>
      

      
        <a href="http://dmonster.top/2017/04/23/BeautifulSoup库/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/19/python学习笔记/" class="article-date">
  <time datetime="2017-04-19T15:23:51.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python3/">python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/python学习笔记/">pyhon学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>元组是不可变序列。</p>
<ul>
<li>空元组：() </li>
<li>一个值的元组： 1, 或(1,)  //其中逗号不可省略</li>
<li><p>多个值的元组： 1, 2, 3 或 (1, 2, 3) </p>
<pre><code>2*(2+3) 输出10 //没有逗号，普通的值计算
2*(2+3,) 输出(5, 5) //有逗号，表示是一个元组，相乘后得到一个新的元组，有两个值
</code></pre></li>
<li>创建一个新元组： X = 1,2,3</li>
<li>访问元祖元素： X[1] //输出2</li>
<li><p>tuple函数：<br>  将序列转换为元组：</p>
<pre><code>tuple([1, 2, 3])  输出(1,2,3)            //列表
tuple(&apos;abc&apos;)      输出(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)     //字符串
tuple((1,2,3))      输出(1,2,3)         //元组
</code></pre></li>
</ul>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>键/值对之间用冒号隔开，项之间用逗号隔开，整个字典用大括号括起来。</p>
<pre><code>phonebook = {&apos;宁波&apos;:&apos;0574&apos;,&apos;台州&apos;:&apos;0576&apos;,&apos;杭州&apos;:&apos;0571&apos;}
phonebook[&apos;宁波&apos;]     //输出:&apos;0574&apos;
</code></pre><ul>
<li><p>dict()函数</p>
<p>  可以使用该函数通过其他映射或（键，值）对序列建立字典</p>
<pre><code>items=[(&apos;name&apos;,&apos;Alice&apos;),(&apos;age&apos;,28)]
d=dict(items)
print d  //输出字典：{&apos;age&apos;: 28, &apos;name&apos;: &apos;Alice&apos;} 
</code></pre><p>  或者用关键字参数形式</p>
<pre><code>d=dict(name=&apos;Alice&apos;,age=28)
print d  //输出字典：{&apos;age&apos;: 28, &apos;name&apos;: &apos;Alice&apos;}
</code></pre></li>
<li>字典的基本操作与元组类似，但是字典是无序的且值可变<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1></li>
</ul>
<h2 id="匿名函数：Lambda"><a href="#匿名函数：Lambda" class="headerlink" title="匿名函数：Lambda"></a>匿名函数：Lambda</h2><ul>
<li><p>匿名函数：</p>
<p>  lambda函数是一种快速定义单行的最小函数，是从lisp借用来的，可以在任何需要函数的地方</p>
</li>
<li><p>使用lambda的好处：</p>
<ol>
<li>使用python写一些执行脚本时，使用lambda可以省去定义函数的过程，让代码更加精简</li>
<li>对于一些抽象的，不会别的地方再复用的函数，有时候给函数起名字也很难，但是使用lambda不需要考虑命名问题</li>
<li>使用lambda在某些时候让代码更容易理解</li>
</ol>
</li>
<li><p>lambda基础：</p>
<ul>
<li>lambda语句中，冒号前是参数，可以有多个，用逗号隔开，冒号右边的返回值。</li>
<li><p>lambda语句构建的其实是一个函数对象：</p>
<pre><code>g = lambda x ： x**2
print g
</code></pre></li>
<li><p>执行匿名函数lambda：reduce(lambda x,y : x*y , range(1,6)) 求6的阶乘</p>
</li>
</ul>
</li>
</ul>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><ul>
<li><p>for 循环</p>
<pre><code>for x in 序列
    执行代码
</code></pre></li>
<li><p>range()函数</p>
<pre><code>range(初始值，终止值，进步值) //指定终止值不包括在内
</code></pre><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2></li>
</ul>
<p>python中没有switch语句，通过字典合资点的get（）函数实现分支结构</p>
<p>例：</p>
<pre><code>from __future__ import division
    //可解决以上问题

def jia(x,y):
return x+y

def jian(x,y):
return x-y

def cheng(x,y):
return x*y

def chu(x,y):
return x/y

def operator(x,o,y):
if o==&quot;+&quot;:
jia(x,y)
elif o == &quot;-&quot;:
jian(x,y)
elif o == &quot;*&quot;:
cheng(x,y)
elif o == &quot;/&quot;:
chu(x,y)
else:
pass

operator(2,&apos;+&apos;,4)
</code></pre><p>如果是除法，先判断加减乘，效率低下，如果输入错误，会做四次无用的判断</p>
<p>switch直接判断条件，如果满足，直接执行</p>
<pre><code>operator = {&quot;+&quot;:jia, &quot;-&quot;:jian,&quot;*&quot;:cheng, &quot;/&quot;:chu}
print operator{&quot;+&quot;} // 对应jia的函数对象

等同于 print jia
</code></pre><p>所以</p>
<pre><code>print operator{&quot;+&quot;} (2,3)

等同于 print jia (2,3)
</code></pre><p>省去判断，如果没有对应的key则报错</p>
<p>所以用get方法，没有对应的key也不会报错</p>
<pre><code>print operator.get(&quot;%&quot;)(3,2) //不会报错

def f(x,o,y):
print operator.get(o)(x,y)

调用
f(3,&quot;+&quot;,2) //输出5 无需判断即可完成

operator.get(o)(x,y,*args,**kwargs)
</code></pre><p>参数更灵活</p>
<p>if能完成的一般都可以用字典实现.</p>
<ul>
<li><p>用字典+函数 实现switch： {1：case1,2:case2}.get()</p>
<pre><code>x=1
y=2
operator=&quot;/&quot;
result = {&quot;+&quot;:x+y, &quot;-&quot;:x-y, &quot;*&quot;:x*y, &quot;/&quot;x/y}
print result.get(operator)
//实现函数相同的功能
</code></pre></li>
</ul>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><ul>
<li>max(l) //返回最大值 l为列表</li>
<li>min(l) //返回最小值</li>
<li>len(l) //l 的长度，l 为序列</li>
<li>divmod(5,2) // 5/2 返回元组(2,1) 商为2 余数为1</li>
<li>cmp(x，y) //比较两个对象x和y!如果x &lt; y ,返回负数；x == y, 返回0；x &gt; y,返回正数。</li>
<li>help(pow) //查找该函数用处</li>
<li>pow(2,3) //返回2^3 = 8</li>
<li>round(10) //10.0</li>
<li>callable(f) //测试某个函数可否被调用,如果f没被定义，则不可调用</li>
<li>isinstance(obj, class_or_tuple) //判断对象的类型！</li>
<li>range() //创造range()对象用于迭代！</li>
<li>type(object) //查看对象类型！</li>
<li>int（）,long(),float(),complex(),list(),tuple(),hex() //转化函数</li>
<li>chr(n) //当传入序号n时，返回n所代表的ASCII码字符的字符串</li>
<li><p>ord(c) //返回单字符字符串的int值（ASCII码值）！</p>
</li>
<li><p>string函数：只用于字符串的操作</p>
<pre><code>str.capitalize() //首字母大写

s = &apos;hello world&apos;
capitalize(s) //错误
s.capitalize() //正确，返回Hello world
</code></pre><p>  capitalize是class中的一个方法，s是string class的一个对象</p>
</li>
<li><p>str.replace() //替换</p>
<pre><code>s.replace(&quot;hello&quot;,&quot;good&quot;) //返回good world
</code></pre><p>  s 的值不变，返回值改变</p>
<pre><code>ss = &quot;123123123&quot;
ss.replace(&apos;1&apos;,&apos;x&apos;) //&apos;x23x23x23
ss.replace(&apos;1&apos;,&apos;x&apos;,1/2/3)&apos; //1/2/3表示替换的次数，从前往后
</code></pre></li>
<li><p>str.split() //用于切割</p>
<pre><code>ip = &quot;192.168.1.123&quot;
ip.split(&apos;.&apos;) //返回列表[192&apos;,&apos;168&apos;. ..]
ip.spliy(&apos;.&apos;,count)//count表示切割的次数，从前往后
</code></pre></li>
<li><p>import string //引入string模块</p>
<pre><code>string.replace(s,hello&apos;,&apos;good&apos;) // &apos;good world&apos;
两种方式
</code></pre></li>
</ul>
<h2 id="序列处理函数"><a href="#序列处理函数" class="headerlink" title="序列处理函数"></a>序列处理函数</h2><ul>
<li><p>len</p>
<pre><code>len(123) //出错 对象只能是序列
len() max() min()
</code></pre></li>
<li><p>filter():</p>
<pre><code>def f(x):
if x &gt; 5:
return True

f(10) //True
l = range(10)
fileter(f, l) //f 函数作用于 l 返回True时会吧结果保留下来 [6,7,8,9]
</code></pre></li>
<li><p>zip()</p>
<pre><code>z = zip([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],[&apos;x&apos;,&apos;y&apos;,&apos;z&apos;])
&gt;&gt;&gt;next(z)
(&apos;a&apos;,&apos;x&apos;)
&gt;&gt;&gt;next(z)
(&apos;b&apos;,&apos;y&apos;)
</code></pre></li>
<li><p>map()</p>
<pre><code>map(None,name,age,tel,test) 
//map遍历事如果某个列表元素不够，用None代替，None可以用函数代替
</code></pre></li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是python组织代码的基本方式，即.py文件</p>
<ul>
<li><p>使用方法：</p>
<ul>
<li>导入模块名即文件名： import xxx</li>
<li><p>引用： xxx.方法</p>
</li>
<li><p>A调用B(B中含执行函数，不希望),在B中写：</p>
<pre><code>if __name__ = &quot;__main__ &quot; 
operator(2,&apos;*&apos;,3)
//如果__name__ = __main__则调用执行函数
//（直接调用 __name__ = __main__，间接调用 __name__ = xxx）
</code></pre></li>
<li><p>导入先后顺序：先在当前目录中找</p>
</li>
</ul>
</li>
<li><p>包</p>
<p>  python模块可按目录组织为包</p>
<ul>
<li>当前目录创建 __init__.py文件，上级目录即可成为一个包</li>
<li>使用时需从上级目录逐级访问</li>
</ul>
</li>
</ul>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>对象方法</p>
<ul>
<li><p>打开</p>
<pre><code>f = open(&apos;文件目录&apos;)
</code></pre></li>
<li><p>关闭： </p>
<pre><code>f = close()
</code></pre></li>
<li><p>读取： </p>
<pre><code>f = read()
</code></pre><ul>
<li>f.readline() //每次读取一行，没有数据则返回空字符串</li>
<li>f.readlines() //把每个数据作为列表中的一个数据，返回列表</li>
<li>f.next() //和readline()迭代一样，但是结束时会停止</li>
</ul>
</li>
</ul>
<ul>
<li><p>写入</p>
<pre><code>f = open(&apos;文件目录&apos;,&apos;r+&apos;)
f.write(&apos;写入的内容&apos;)
</code></pre><ul>
<li>f.writelines(列表) //写入多行数据</li>
<li>f.flush() //断点续传，提交<br>（注意文件中指针的位置）</li>
<li>a：在文件末尾写入</li>
<li>a+： 在文件末尾读写</li>
<li>r： 只读</li>
<li>r+：读写</li>
<li>w：重新写入</li>
<li>w+：重新读写</li>
</ul>
</li>
<li><p>f.seek(偏移量,选项) </p>
<ul>
<li>选项 = 0，文件指针指向从文件头部到‘偏移量字’节处</li>
<li>选项 = 1，文件指针指向从文件的当前位置向后移动‘偏移量’字节</li>
<li>选项 = 2，文件指针指向从文件的尾部向前移动‘偏移量’字节处</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2017/04/19/python学习笔记/" data-id="cjizrkli0001f0gugta021a5n" class="article-share-link" data-share="baidu" data-title="pyhon学习笔记">分享到</a>
      

      
        <a href="http://dmonster.top/2017/04/19/python学习笔记/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python爬虫入门实验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/19/python爬虫入门实验/" class="article-date">
  <time datetime="2017-04-19T14:32:51.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python3/">python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/python爬虫入门实验/">python爬虫入门实验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <p>爬百度贴吧里的图片</p>
<pre><code>#!/usr/bin/python
import re
import urllib //加载模块

def getHtml(url):    // 获取地址
    page = urllib.urlopen(url)    //打开
    html = page.read()    //读取
    return html

def getImg(html):    //获取并下载图片
    reg = r&apos;&lt;img class=&quot;BDE_Image&quot; src=&quot;(.*?)&quot; &apos;    //关键！！！查看页面元素写正则表达式
    imgre = re.compile(reg)        //预编译
    imglist = re.findall(imgre,html)    //匹配
    x = 0
    for imgurl in imglist:
        urllib.urlretrieve(imgurl,&apos;%s.jpg&apos; %x)    //下载函数
        x+=1

html =  getHtml(&quot;https://tieba.baidu.com/p/2237770604&quot;)
print getImg(html)
</code></pre>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2017/04/19/python爬虫入门实验/" data-id="cjizrklhd00150gug6kab8m9n" class="article-share-link" data-share="baidu" data-title="python爬虫入门实验">分享到</a>
      

      
        <a href="http://dmonster.top/2017/04/19/python爬虫入门实验/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小玩意/">小玩意</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/19/正则表达式/" class="article-date">
  <time datetime="2017-04-19T09:28:45.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python3/">python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/正则表达式/">正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>python标准库为使用正则表达式提供了re模块</p>
<ul>
<li><p>re.search使用：</p>
<pre><code>re.search(r&apos;fox&apos;,&apos;the quick brown fox jumped&apos;)
//从字符串中寻找fox返回发现的第一个匹配,若找不到则返回none
</code></pre></li>
<li><p>mach 对象</p>
<pre><code>re.search(r&apos;fox&apos;,&apos;the quick brown fox jumped&apos;)
</code></pre><ul>
<li><p>group方法</p>
<pre><code>match.group() //输出 fox
</code></pre></li>
</ul>
</li>
<li><p>找到多个匹配</p>
<pre><code>re.search(r&apos;o&apos;,&apos;the quick brown fox jumped&apos;)
//返回  [&apos;o&apos;,&apos;o&apos;]
</code></pre></li>
</ul>
<h1 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h1><ul>
<li><p>字符组</p>
<pre><code>re.search(r&apos;[Pp]ython&apos;,&apos;python 3&apos;) //匹配到 python
re.search(r&apos;[Pp]ython&apos;,&apos;Python 3&apos;) //匹配到 Python
</code></pre><ul>
<li><p>区间</p>
<pre><code>re.search(r&apos;[a-zA-Z]&apos;,&apos;x&apos;) //匹配到 x
re.search(r&apos;[a-zA-Z]&apos;,&apos;B&apos;) //匹配到 B
</code></pre></li>
<li><p>取反</p>
<pre><code>re.search(r&apos;[^a-z]&apos;,&apos;4&apos;) //匹配到 4
</code></pre></li>
<li><p>快捷方式</p>
<ul>
<li><p>\w :匹配所有字符</p>
<pre><code>re.search(r&apos;\w&apos;,&apos;python 3&apos;) //匹配到 p
re.findall(r&apos;\w&apos;,&apos;python 3&apos;) //匹配到 [&apos;p&apos;,&apos;y&apos;,&apos;h&apos;,&apos;o&apos;,&apos;n&apos;]
</code></pre></li>
<li><p>\d :匹配所有数字字符</p>
</li>
<li>\s :匹配所有空白字符</li>
<li>. ：匹配任意字符</li>
<li>取反： \W, \d, \S</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串的开始与结束</p>
<ul>
<li><p>开始</p>
<pre><code>re.search(r&apos;^python&apos;,&apos;python 3&apos;) //匹配到 python
re.search(r&apos;^python&apos;,&apos;hello python &apos;) //不是以pyhon开头，匹配不到
</code></pre></li>
<li><p>结束</p>
<pre><code>re.search(r&apos;python$&apos;,&apos;hello python&apos;) //匹配到python
re.search(r&apos;python$&apos;,&apos;python 3&apos;) //匹配不到，不是以python结束
</code></pre></li>
</ul>
</li>
<li><p>可选字符</p>
<pre><code>re.search(r&apos;honou?r&apos;,&apos;He served with honor.&apos;) //匹配到honor
re.search(r&apos;honou?r&apos;,&apos;He served with honour.&apos;) //匹配到honour
</code></pre></li>
<li><p>重复</p>
<pre><code>re.search(r&apos;[\d]{3}-[\d]{4}&apos;,&apos;867-5309 / J&apos;) //匹配到 867-5309
</code></pre><ul>
<li><p>重复区间</p>
<pre><code>re.search(r&apos;[\d]{3,4}&apos;,&apos;123&apos;) //匹配到123
re.search(r&apos;[\d]{3,4}&apos;,&apos;1234&apos;) //匹配到 1234
</code></pre></li>
<li><p>开闭区间</p>
<pre><code>re.search(r&apos;[\d]{1, }&apos;,&apos;1000000&apos;) //匹配到1000000
</code></pre></li>
<li><p>速写</p>
<ul>
<li>用 + 代替 {1, }</li>
<li>用 * 代替 {0, }</li>
</ul>
</li>
<li><p>分组</p>
<pre><code>match = re.search(r&apos;[\d]{3}-[\d]{4}&apos;,&apos;867-5309 / J&apos;)

match.group() //输出（&apos;867-5309&apos;）
match.groups() //输出（&apos;867&apos;,&apos;5309&apos;）
match.groups(1) //输出（&apos;867&apos;）
</code></pre></li>
</ul>
</li>
<li><p>零分组<br>如果group()不带参数，则默认参数为0，所以输出分组参数从1开始。</p>
</li>
<li><p>命名分组<br>命名语法?P<group name\=""></group></p>
<pre><code>match = re.seach(&apos;r&apos;(?P&lt;first_three&gt;[\d]{3})-(?P&lt;last_four&gt;[\d]{4})&apos;,&apos;867-5309&apos;)

match.group(&apos;first_three&apos;) //输出&quot;867&quot;
</code></pre></li>
</ul>
<p>此外，match提供一个groupdict方法，该方法在大多数方面和groups类似，但是他返回的是一个字典不是元组。</p>
<ul>
<li>引用已经存在的分组</li>
</ul>
<h1 id="先行断言"><a href="#先行断言" class="headerlink" title="先行断言"></a>先行断言</h1><ul>
<li><p>取反先行断言</p>
<pre><code>re.search(r&apos;n(?!e)&apos;,&apos;final&apos;) // 匹配到 n
//不同于取反，不返回取反的字符
</code></pre></li>
<li><p>正向先行断言</p>
<pre><code>re.search(r&apos;n(?=e)&apos;,&apos;jasmine&apos;) //匹配到 n
</code></pre></li>
</ul>
<h1 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h1><ul>
<li><p>不区分大小写</p>
<p>  re.IGNORECASE / re.I</p>
<pre><code>re.search(r&apos;python&apos;, &apos;PYTHON IS OS GOOD&apos;, re.IGNORECASE) // 匹配到 python
</code></pre></li>
<li><p>点匹配换行符</p>
<p>  re.DOTALL / re.S</p>
<pre><code>re.search(r&apos;.+&apos;,&apos;foo\nbar&apos;) //匹配到foo 
re.search(r&apos;.+&apos;,&apos;foo\nbar&apos;,re.DOTALL) //匹配到foo/nbar
</code></pre></li>
<li><p>多行模式</p>
<p>  re.MULTILINE / re.M</p>
<pre><code>re.search(r&apos;^bar&apos;,&apos;foo\nbar&apos;) //因为nabr在下一行，所以匹配不到
re.search(r&apos;^bar&apos;,&apos;foo\nbar&apos;,re.MULTILINE) //匹配到bar
</code></pre></li>
<li><p>详细模式</p>
<p>  re.VERBOSE / re.X</p>
</li>
<li><p>调试模式</p>
<p>  re.DEBUG</p>
<pre><code>match = re.seach(&apos;r&apos;(?P&lt;first_three&gt;[\d]{3})-(?P&lt;last_four&gt;[\d]{4})&apos;,&apos;867-5309&apos;,re.DEBUG) //输出调试信息
</code></pre></li>
<li><p>使用多个标记</p>
<pre><code>re.S | re.M
</code></pre></li>
</ul>
<h1 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h1><p>从一个字符串中剥离无关数据</p>
<pre><code>re.sub(r&apos;\+?1&apos;?[ .-]?\(?([\d]{3})\)?[ .-]?([\d]{3})[ .-]?([\d]{4})&apos;,r&apos;\2\3\4&apos;,&apos;213-867-5309&apos;) //匹配到2138675309

re.sub(r&apos;\+?1&apos;?[ .-]?\(?([\d]{3})\)?[ .-]?([\d]{3})[ .-]?([\d]{4})&apos;,r&apos;(\2) \3-\4&apos;,&apos;+1 213-867-5309&apos;) //匹配到(213) 867-5309
</code></pre><p>（ ()\1 表示重复正则第一个圆括号内匹配到的内容 ）</p>
<h1 id="已编译的正则表达式"><a href="#已编译的正则表达式" class="headerlink" title="已编译的正则表达式"></a>已编译的正则表达式</h1><pre><code>regex = re.compile(r&apos;\+?1&apos;?[ .-]?\(?([\d]{3})\)?[ .-]?([\d]{3})[ .-]?([\d]{4})&apos;)

regex.search(&apos;213-867-5309&apos;) //匹配到 213-867-5309
regex.sub(r&apos;(\2) \3-\4&apos;,&apos;+1 213-867-5309&apos;) //匹配到 (213) 867-5309
</code></pre>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://dmonster.top/2017/04/19/正则表达式/" data-id="cjizrklii001s0gugwrlai8a0" class="article-share-link" data-share="baidu" data-title="正则表达式">分享到</a>
      

      
        <a href="http://dmonster.top/2017/04/19/正则表达式/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python3/">python3</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">10</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCIE/">CCIE</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCNA/">CCNA</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCNP/">CCNP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小玩意/">小玩意</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a><span class="tag-list-count">14</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">6</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/28/mysql-prox搭建以及遇到的问题/">mysql-prox搭建以及遇到的问题</a>
          </li>
        
          <li>
            <a href="/2018/06/26/centos上搭建shadowsocks的两种方法/">centos上搭建shadowsocks的两种方法</a>
          </li>
        
          <li>
            <a href="/2018/06/26/CDN内容分发网络/">CDN内容分发网络</a>
          </li>
        
          <li>
            <a href="/2018/03/26/python爬虫之验证码识别/">python爬虫之验证码识别</a>
          </li>
        
          <li>
            <a href="/2018/03/25/windows下安装redis/">windows下安装redis</a>
          </li>
        
      </ul>
    </div>
  </div>

  
     
	<div class="widget-wrap"> 
		<h3 class="widget-title">Weibo show</h3> 
		<div class="widget-weibo"> 
			<iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=5&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=5753916666&verifier=c645597d&dpc=1"></iframe>
		</div> 
	</div> 

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 dmonster<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/sitemap.xml" class="mobile-nav-link">sitemap</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
